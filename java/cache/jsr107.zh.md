# JSR107中文版（非官方）

最近在学缓存这块，没找到现成的中文文档，翻译一份给大家。最终版有多个，这里翻译的是[JSR107 Specification 1.1.1 Maintenance Release - Google Doc](https://docs.google.com/document/d/1ijduF_tmHvBaUS7VBBU2ZN8_eEBiFaXXg9OI0_ZxCrA/edit?usp=sharing)。

本文内容仅限于学习使用，为了便于理解，翻译并不是单词对汉语的直译，建议阅读时和英文原文进行对照。

## 引言

本规范描述了 Java缓存API 的目标和功能。

Java缓存API 为 Java 程序提供了可用于从缓存中创建，访问，更新和删除条目的统一抽象。

### 概览

缓存在提高应用程序性能和可伸缩性上非常有效。

缓存在是将数据副本以低延迟能够获取的结构保存一段时间，以便于请求相同信息时能够更快响应。

缓存适用于那些创建或访问代价比较高的应用。比如一个频繁访问的 JavaWeb Servlet 网页，里面包括多次数据库访问，网络请求，和比较耗时的计算任务；中间用到的数据可能是可以直接重用的，把这些信息缓存起来，下次访问时直接读取可以减少页面构建的时间。

Java缓存API提供了一种使用缓存的通用方式，从而使开发者专注于应用本身的开发。本规范定义了缓存的术语、语义和响应的Java接口

### 什么是缓存

缓存在计算中无处不在。在应用程序设计领域中，它通常代表开发者使用内存或低延迟的数据结构来临时存储缓存数据的副本或引用，以便以后进行重用来减少重新访问或重新创建的成本。

在 Java缓存API领域中，术语“缓存”代表的是Java开发者使用缓存组件临时缓存Java对象的技术。

通常缓存的是数据库的数据，但这并不是必须的，任何创建或访问比较昂贵或耗时的数据都可以进行缓存，比如：

1. Web服务调用的客户端缓存
2. 昂贵的计算，例如渲染的图像
3. 数据缓存
4. servlet响应缓存
5. 领域对象图（caching of domain object graphs）

### 目标

Java缓存AIP 的目标是：

1. 为应用程序提供缓存功能，尤其是缓存Java对象的能力。
2. 定义一套通用的缓存概念和设施。
3. 减少Java开发人员采用缓存的学习成本。
4. 最大化应用程序切换缓存实现的能力。
5. 支持进程内和分布式缓存实现。
6. 支持按值和（可选）按引用缓存Java对象。
7. 参照 JSR-175 定义运行时缓存注解，以便开发者可以使用注解处理器来支持声明式缓存。

### 非目标

Java缓存API 无法解决的问题：

1. 资源和内存限制配置。很多缓存实现都提供了约束运行时可使用资源的配置，但是这并不是本规范的内容。本规范只提供了一种标准机制使开发者去指定数据缓存的时长。
2. 缓存数据的存储形式。本规范未指定缓存实现如何存储或表示缓存的数据。
3. 管理。本规范并未规定如何管理缓存。仅定义了编程式配置缓存的机制和通过 JMX 来操作缓存统计信息的机制。
4. 安全性。本规范未指定如何保​​护缓存内容或如何控制对缓存的访问和操作。
5. 缓存和数据源数据同步。本规范未指定应用程序或缓存实现应如何使缓存和数据源数据保持一致。尽管开发者可以使用 `read-through` 和 `write-through` 技术，但是这些技术只能保证数据通过缓存更新数据源时的一致性，如果应用程序不经过缓存直接写数据源，此时缓存和数据源的数据一致性就无法保证。

### Java SE 和 Java EE 支持

Java缓存API兼容标准版和企业版（版本6或更高版本）的应用程序。缓存实现可以选择只在更高版本的Java上运行，可以支持使用 JavaEE 的应用，但是本规范并未定义如何实现。

### 包名

顶级包名是 `javax.cache`。

### 可选特性

本规范中的所有特性都是强制性必须实现的，但 `OptionalFeature` 枚举中列出的功能除外：

`storeByReference`

如果实现，则必须完全按照本规范中的描述来实现。

开发者可以使用 `cachingProvider.isSupported(OptionalFeature feature)` 确定缓存提供程序已实现了哪些可选功能。

一些可选功能仅在特定情况下才有意义。 例如，分布式缓存通常不支持 `storeByReference`。

可选功能允许缓存实现不必支持所有功能，并且允许最终用户和框架发现支持的特性是什么，以便他们可以动态配置适当的用法。

### 文档规范

`Arial (11磅)` 字体用于该规范的正文。

斜体 `Arial (11磅)` 字体用于包含非正文性信息的段落，例如描述典型用法的注释或使用说明性规范澄清文本的注释。

`Courier New（11磅）` 字体用于代码。 Java代码，示例和示例数据片段也使用Courier New字体。 格式如下（10点字体）：

```java
package com.example.hello;
public class Hello {
    public static void main(String args[] {
        System.out.println(“Hello Worlds”);
    }
}
```

另外，这些关键字‘MUST’, ‘MUST NOT’, ‘REQUIRED’, ‘SHALL’, ‘SHALL NOT’, ‘SHOULD’, ‘SHOULD NOT’, ‘RECOMMENDED’, ‘MAY’, and ‘OPTIONAL’ 应按照[RFC 2119](https://tools.ietf.org/html/rfc2119) 中的说明进行解释。

### 专家组成员

This speciﬁcation is being developed under the Java Community Process v2.9.

Leading experts throughout the entire Java community have come together to build this Java caching standard.

The following are expert group members:

- Greg Luck
- Brian Oliver, Oracle
- Cameron Purdy, Oracle
- Galder Zamarreño, Red Hat
- Nikita Ivanov, Grid Gain
- Chris Berry
- Jon Stevens
- Rick Hightower
- Ben Cotton, Credit Suisse
- David Mossakowski, Citigroup
- Bongjae Chang
- Steve Millidge
- Gabe Montero, IBM
- Brian Martin, IBM
- Eric Dalquist
- Pete Muir, Red Hat, Inc.
- William Newport, Goldman Sachs
- Ryan Gardner, Dealer.com
- Chris Dennis, Terracotta, Inc.
- Toshio Takeda, Fujitsu
- Chang Paek, TmaxSoft, Inc.

The following are official observers:

- Linda DeMichiel, Oracle
- Bill Shannon, Oracle
- Jens Wilke (Jens contributed very heavily to the 1.1 MR)

### 致谢

During the course of the JSR we have received many excellent suggestions on the JSR mailing lists. Thanks to those people.

## 基本原理

### 核心概念

Java Caching API定义了五个核心接口：`CachingProvider`，`CacheManager`，`Cache`，`Entry`和`ExpiryPolicy`。

`CachingProvider` 用于创建，配置，获取，管理和控制零个或多个`CacheManager` 。应用程序可以在运行时访问和使用零个或多个`CachingProvider`。

`CacheManager` 用于创建，配置，获取，管理和控制零个或更多个唯一命名的 `Cache`。 `CacheManager` 由单个 `CachingProvider` 拥有。

`Cache`是一种类似于 `Map` 的数据结构，它允许临时存储基于键的值。`Cache` 由单个`CacheManager` 拥有。

`Entry` 是由 `Cache` 存储的单个键值对。

`Cache` 中的每个 `Entry` 都有一个有效时间，在此期间可以进行访问，更新和删除操作。一旦超过此持续时间，就称该条目已过期。一旦过期，条目将不再可用于访问，更新或删除，就好像它们从未存在于缓存中一样。使用 `ExpiryPolicy` 设置到期时间。

![jsr107-core-interface-class-diagram](http://image.rainstorm.vip/blog/jsr107-core-interface-class-diagram.png)

[图片源文件](../../res/jsr107-core-interface-class-diagram.pu)

### 按值存储和按引用存储

`Cache` 存储 `Entry` 的方式有两种，一个是按值存储，一个是按引用存储

`javax.cache.configuration.MutableConfiguration#isStoreByValue` 字段定义了是否按值存储，可以在创建 `Cache` 时进行配置。默认是 `true` 代表安值存储

按值存储：将应用程序提供的键和值存储缓存之前先对其进行复制，访问时从缓存中返回条目的新副本。复制条目（存储在缓存中）以及从缓存返回时再次复制条目的目的是允许应用程序继续更改键和值的状态，而不会对缓存所保存的条目产生副作用。

Java序列化是实现键和值副本的一种简单方法。

为了确保实现之间的可移植性，建议在使用按值存储时，自定义键和值类实现并采用标准Java序列化。

实现用来复制键和条目值的机制可以是可自定义的。但是，为了确保应用程序的可移植性，实现必须允许应用程序仅使用标准Java序列化。实现不得强制应用程序采用非标准Java序列化。

按引用存储是一种可选方案，它代表 `Cache` 实现仅存储和返回对应用程序提供的键和值的引用，而不是按按值存储方法进行复制。如果应用程序稍后使用按引用存储的语义来更改提供给缓存的键或值，则那些从缓存访问条目的人将可以看到突变的副作用，而无需应用程序更新缓存。

对于在Java堆上实现的缓存，按引用存储相对更快。

Tips:

> Heap only: When using heap only caches, the default is by-reference unless you configure a Copier.
>
> Ehcache 3.8 仅使用堆存储层时，默认使用按引用存储，除非显式配置了一个 Copier
>
> https://www.ehcache.org/documentation/3.8/107.html

```xml
<default-copiers>
    <copier type="me.rainstorm.demo.cache.domain.Person">org.ehcache.impl.copy.SerializingCopier</copier>
</default-copiers>
```

### 缓存与 `Map`

缓存和 `Map` API 相似，下面简单描述主要的异同点

相同点：

1. 通过 key 进行存储和访问
2. 每个 key 仅与一个值进行关联
3. 可变对象作为 key 时需要特别注意，如果 key 发生了变化，且变化对 `equals` 方法有影响，此时缓存的行为是未定义的。
4. 缓存使用相等性来判断给定的 key 或 value 是否已存在，自定义的类做为 key 或 value 时 推荐实现合适的 `Object.equals` 和 `Object.hashCode` 方法。

不同点：

1. 缓存键和值不能为null。
   - 任何尝试为键或值使用null都会导致抛出NullPointerException
2. 条目可能会过期。
   - 确保条目不再对应用程序有效（因为它们不再被视为有效）的过程称为“到期”
3. 条目可能会被驱逐。
   - 缓存通常用于存储整个数据集经常使用的一小部分子集，当空间不够时就会按照一定策略进行驱逐条目。
   - 当缓存超过资源限制时从缓存中删除条目的过程称为“逐出（eviction）”。当由于资源限制而从缓存中删除条目时，该条目被称为“被驱逐（evicted）”。
   - 虽然规范没有定义缓存的容量，但是推荐缓存实现提供一种当达到容量限制时，结合适当的驱逐策略，来选择和驱逐条目的机制。例如：LRU逐出策略试图逐出最近最少使用的条目。
   - 规格中未定义容量的一些原因是：
     - 实现可以利用多层分层存储结构，从而定义每层的容量。在这种情况下，无法定义缓存的整体容量。
     - 实现可以按字节而不是每个层上的条目数定义容量。
     - 就内存而言，条目的相对成本与运行时条目实现的内部表示直接相关。
4. 为了支持原子比较并交换（CAS）操作，自定义值类应提供 `Object.equals` 的适当实现。
5. 实现可能要求键和值以某种方式可序列化。
6. 缓存可以配置为使用按值存储或可选地使用按引用存储来控制条目的存储方式。
7. 实现可以选择强制实施安全性限制。 如果发生违规，则必须抛出`SecurityException`。

尽管建议这样做，但缓存实现调用由自定义键类定义的 `Object.hashCode` 或 `Object.equals` 方法并不是必须的。缓存实现可以自由优化，从而避免调用这些方法。

由于本规范未定义对象等效性的概念，因此，依赖于缓存实现的等效性优化来确定自定义键类等效性的应用程序可能无法移植。

### 一致性

一致性指的是，当多个线程同时访问一个缓存时，保证并发修改的可见性是一致的。

PS，这句话翻译的感觉不是特别好，放出原文。

> Consistency refers to the behavior of caches and the guarantees that exist when concurrent cache mutation occur together with the visibility of the mutations when multiple threads are accessing a cache.

所有缓存实现必须要支持默认一致性模型。

#### 默认一致性

使用默认的一致性模式时，大多数高速缓存操作在执行时，就好像缓存中的每个键都存在加锁机制一样。 当缓存操作获得对某个键的排他性读写锁时，对该键的所有后续操作都将阻塞，直至锁释放。 两个线程执行操作时，遵循 happen-before 原则（包括不同Java虚拟机中的线程）。

可以理解为一个悲观锁，以加锁，修改，解锁来保证一致性。

对于那些有返回值的缓存操作，返回的缓存值是最新的值，但是这个最新的值的定义，根据缓存实现的不同，可以选择操作前的值，也可以选择是操作后的值。

这可以理解为没有保证一致性的无锁方法。ps：不理解这句话

部分操作遵循不同的惯例，这些操作在条目的缓存值满足某种预期的状态时才进行修改。这些操作在多线程环境下好像共享一个锁，这个可以理解为是一种优化的加锁方式，这类加锁方式叫 CAS

```java
boolean putIfAbsent(K key, V value);
boolean remove(K key, V oldValue);
boolean replace(K key, V oldValue, V newValue);
boolean replace(K key, V value);
V getAndReplace(K key, V value);
```

想其他缓存操作一样，CAS 操作在写新值时也需要表现的像是获得了一个排它锁。

在默认一致性下，尽管CAS方法可以允许更高级别的并发性，但它们将被非CAS方法所阻止。
>As a result, in default consistency, while the CAS methods can allow a higher level of concurrency they will be held up by the non-CAS methods.

下表显示了适用于每个Cache方法的默认一致性。

|方法|默认一致性|
|---|---|
|`boolean containsKey(K key)`| 最新值|
|`V get(K key)`| happen-before |
|`Map<K,V> getAll(Collection<? extends K> keys)`|对里面的每个key，而不是整个集合|
|`V getAndPut(K key, V value)`|happen-before|
|`V getAndRemove(K key)`|happen-before|
|`V getAndReplace(K key, V value)`|happen-before + CAS|
|`CacheManager getCacheManager()`|N/A|
|`CacheConfiguration getConfiguration()`|N/A|
|`String getName()`|N/A|
|`Iterator<Cache.Entry<K, V>> iterator()`|最新值|
|`void loadAll(Set<? extends K> keys, boolean replaceExistingValues, CompletionListener listener)`|N/A|
|`void put(K key, V value)`|happen-before|
|`void putAll(Map<? extends K,? extends V> map)`|对里面的每个key，而不是整个集合|
|`boolean putIfAbsent(K key, V value)`|happen-before + CAS|
|`boolean remove(K key)`|happen-before|
|`boolean remove(K key, V oldValue)`|happen-before + CAS|
|`void removeAll()`|最新值|
|`void removeAll(Set<? extends K> keys)`|happen-before + CAS|
|`<T> T invoke(K key, EntryProcessor<K, V, T> entryProcessor, Object... arguments)entryProcessor);`|happen-before|
|`<T> Map<K, EntryProcessorResult<T>> invokeAll(Set<? extends K> keys,EntryProcessor<K, V, T> entryProcessor, Object... arguments);`|对里面的每个key，而不是整个集合|
|`boolean replace(K key, V value)`|happen-before + CAS|
|`boolean replace(K key, V oldValue, V newValue)`|happen-before + CAS|
|`<T> T unwrap(Class<T> cls)`|N/A|

#### 高级一致性模型

具体实现可以自行拓展一致性模型。

### 缓存拓扑

尽管本规范并没有规定特定的缓存实现结构，但是显而易见的，缓存实体可以存储到当前进程本地和/或分布到多个进程。具体实现可以任意选择合适的结构。

这个概念在规范有多中表现形式:

- 大多数修改方法要么返回 `void` 要么返回一个低成本的值。比如 `java.util.Map` 提供了 `V put(K key, V value)`，但是 `javax.cache.Cache` 提供的是 `void put(K key, V value)`。返回类型成本更高的版本也有提供，比如 `V getAndPut(K key, V value)`，其中的返回值是旧值和 `Map` 相似。
- 通过创建不假设实现将缓存数据放在进程内部的语义，`Configuration` 实现了 `Serializable` 接口已支持在网络中传输。开发者可以定义 `CacheEntryListener`、`ExpiryPolicy`、`CacheEntryFilter`、`CacheWriter` 和 `CacheLoader` 并将它们和 `Cache` 进行关联。为了支持分布式结构，开发者需要定义一个工场去创建它们，这个工厂需要实现 `Serializable` 接口。
- 在整个规范中，对于那些可能很大的返回值和参数使用 `Iterable` 进行遍历。一个 `Cache` 可能很大以至于 key-set 不能完整的保存到可用内存中，并且网络也不好。`Cache`、`CacheEntryListener` 子接口上的监听器方法、`CacheLoader` 的批处理方法都使用 `Iterable` 接口。
- `CacheEntryListener`,`ExpiryPolicy`,`CacheEntryFilter`,`CacheWriter`,`CacheLoader` 这些类在哪里实现，什么时间实例化，和执行本规范不做限制。（在分布式实现中，这些可以全部与数据存放在一起，而不是随网络传输）
- `CachingProvider.getCacheManager(URI uri, ClassLoader classLoader)` 对特定的 `URI` 和 `ClassLoader` 来说有唯一的 `CacheManager`，这确保了实现能够实例化多个实例。

### 执行上下文

`EntryProcessor`, `CacheEntryListener`, `CacheLoader`, `CacheWriter` and `ExpiryPolicy` 的上下文是 `CacheManager` 这就意味着，在部署时，创建 `CacheManager` 的 `ClassLoader` 需要能够访问应用程序类。

类的可用性这个目标如何实现可以由具体的实现自行定义。例如，在 Java EE 环境中，应用程序定义的上述类都包含在企业应用程序的 ear/war/jar 中。

尽管上述类和应用程序类使用同一个 `ClassLoader`，从而获得直接访问所有资源的权限，但是，为了保证可移植性，上述自定义类应该仅用来尝试访问或更新缓存。

在实现和部署环境中，上述自定义类可以利用一些实用技术比如依赖注入来允许直接访问应用程序和部署专用资源，但是并不需要实现去支持这个功能。

### 可重入

尽管此规范不限制开发人员在使用自定义 `EntryProcessor`，`CacheEntryListener`，`CacheLoader`，`CacheWriter` 和 `ExpiryPolicy` 时可能执行的操作，但缓存实现可能会限制这些接口的重入。 例如; 一个实现可能会限制 `EntryProcessor` 调用 `Cache` 上的方法或调用其他 `EntryProcessor` 的能力。 同样，实现可能会限制 `CacheLoader / CacheWriter` 访问缓存的能力。

因此，强烈建议开发人员避免编写这些接口的可重入实现，因为这些实现可能不是可移植的。

## 一个简单的例子

### String.class,Interger.class

这个简单例子穿件一个默认的 `CacheManager`，配置一个名叫 "simpleCache" 的缓存，使用 `String` 做 key，`Integer` 为 value，一个小时无访问过期，然后做了一些缓存操作

```java
//resolve a cache manager
CachingProvider cachingProvider = Caching.getCachingProvider();
CacheManager cacheManager = cachingProvider.getCacheManager();

//configure the cache
MutableConfiguration<String, Integer> config =
new MutableConfiguration<>()
    .setTypes(String.class, Integer.class)
    .setExpiryPolicyFactory(AccessedExpiryPolicy.factoryOf(ONE_HOUR))
    .setStatisticsEnabled(true);

//create the cache
Cache<String, Integer> cache = cacheManager.createCache("simpleCache", config);

//cache operations
String key = "key";
Integer value1 = 1;
cache.put("key", value1);
Integer value2 = cache.get(key);
assertEquals(value1, value2);
cache.remove(key);
assertNull(cache.get(key));
```

在上面的例子中，`CacheingProvider` 和 `CacheManager` 使用的都是默认的实现。除了上面的获取缓存的方法以外，还有下面一种

```java
//get the cache
Cache<String, Integer> cache = Caching.getCache("simpleCache",
    String.class, Integer.class);

```

## `CacheManager`

`CacheManeger` 是 Java caching API 的核心概念。开发者通过 `CacheManager` 与 `Cache` 交互。

`CacheManager` 提供以下能力：

- 创建和配置有唯一名称的 `Cache`。
- 通过缓存名获取 `Cache`。
- 限定 `Cache` 的命名空间， 具有相同名称但源自不同缓存管理器的缓存被视为不同缓存。
- 当不再需要缓存管理的时候关闭缓存。
- 注销 `Cache` 和其中缓存的数据。
- 如果需要，`Cache` 将使用 `ClassLoader` 加载所需的应用类。
- 迭代当前被管理的 `Cache`。
- 关闭 `CacheManager` 和其管理的 `Cache`。
- 启用和禁用 `Cache` 统计数据收集。
- 启用和禁用 `Cache` 的 JMX 管理。
- 获取 `CachingProvider` 为 `CacheManager` 定义的属性。
- 查询 `CachingProvider` 提供的能力和可选特性。

`CacheManager` 的接口定义：

```java

/**
 * A {@link CacheManager} provides a means of establishing, configuring,
 * acquiring, closing and destroying uniquely named {@link Cache}s.
 * <p>
 * {@link Cache}s produced and owned by a {@link CacheManager} typically share
 * common infrastructure, for example, a common {@link ClassLoader} and
 * implementation specific {@link Properties}.
 * <p>
 * Implementations of {@link CacheManager} may additionally provide and share
 * external resources between the {@link Cache}s being managed, for example,
 * the content of the managed {@link Cache}s may be stored in the same cluster.
 * <p>
 * By default {@link CacheManager} instances are typically acquired through the
 * use of a {@link CachingProvider}.  Implementations however may additionally
 * provide other mechanisms to create, acquire, manage and configure
 * {@link CacheManager}s, including:
 * <ul>
 * <li>making use of {@link java.util.ServiceLoader}s,</li>
 * <li>permitting the use of the <code>new</code> operator to create a
 * concrete implementation, </li>
 * <li>providing the construction through the use of one or more
 * builders, and</li>
 * <li>through the use of dependency injection.</li>
 * </ul>
 * <p>
 * The default {@link CacheManager} however can always be acquired using the
 * default configured {@link CachingProvider} obtained by the {@link Caching}
 * class.  For example:
 * <pre><code>
 * CachingProvider provider = Caching.getCachingProvider();
 * CacheManager manager = provider.getCacheManager();
 * </code></pre>
 * <p>
 * Within a Java process {@link CacheManager}s and the {@link Cache}s they
 * manage are scoped and uniquely identified by a {@link URI},  the meaning of
 * which is implementation specific. To obtain the default {@link URI},
 * {@link ClassLoader} and {@link Properties} for an implementation, consult the
 * {@link CachingProvider} class.
 *
 *
 * @author Greg Luck
 * @author Yannis Cosmadopoulos
 * @author Brian Oliver
 * @see Caching
 * @see CachingProvider
 * @see Cache
 * @since 1.0
 *
 */
public interface CacheManager extends Closeable {

  /**
   * Get the {@link CachingProvider} that created and is responsible for
   * the {@link CacheManager}.
   *
   * @return the CachingProvider or <code>null</code> if the {@link CacheManager}
   *         was created without using a {@link CachingProvider}
   */
  CachingProvider getCachingProvider();

  /**
   * Get the URI of the {@link CacheManager}.
   *
   * @return the URI of the {@link CacheManager}
   */
  URI getURI();

  /**
   * Get the {@link ClassLoader} used by the {@link CacheManager}.
   *
   * @return  the {@link ClassLoader} used by the {@link CacheManager}
   */
  ClassLoader getClassLoader();

  /**
   * Get the {@link Properties} that were used to create this
   * {@link CacheManager}.
   * <p>
   * Implementations are not required to re-configure the
   * {@link CacheManager} should modifications to the returned
   * {@link Properties} be made.
   *
   * @return the Properties used to create the {@link CacheManager}
   */
  Properties getProperties();

  /**
   * Creates a named {@link Cache} at runtime.
   * <p>
   * If a {@link Cache} with the specified name is known to the {@link
   * CacheManager}, a CacheException is thrown.
   * <p>
   * If a {@link Cache} with the specified name is unknown the {@link
   * CacheManager}, one is created according to the provided {@link Configuration}
   * after which it becomes managed by the {@link CacheManager}.
   * <p>
   * Prior to a {@link Cache} being created, the provided {@link Configuration}s is
   * validated within the context of the {@link CacheManager} properties and
   * implementation.
   * <p>
   * Implementers should be aware that the {@link Configuration} may be used to
   * configure other {@link Cache}s.
   * <p>
   * There's no requirement on the part of a developer to call this method for
   * each {@link Cache} an application may use.  Implementations may support
   * the use of declarative mechanisms to pre-configure {@link Cache}s, thus
   * removing the requirement to configure them in an application.  In such
   * circumstances a developer may simply call either the
   * {@link #getCache(String)} or {@link #getCache(String, Class, Class)}
   * methods to acquire a previously established or pre-configured {@link Cache}.
   *
   * @param <K> the type of key
   * @param <V> the type of value
   * @param <C> the type of the Configuration
   * @param cacheName     the name of the {@link Cache}. Names should not use
   *                      forward slashes(/) or colons(:), or start with
   *                      java. or javax. These prefixes are reserved.
   * @param configuration a {@link Configuration} for the {@link Cache}
   * @throws IllegalStateException         if the {@link CacheManager}
   *                                       {@link #isClosed()}
   * @throws CacheException                if there was an error configuring the
   *                                       {@link Cache}, which includes trying
   *                                       to create a cache that already exists.
   * @throws IllegalArgumentException      if the configuration is invalid
   * @throws UnsupportedOperationException if the configuration specifies
   *                                       an unsupported feature
   * @throws NullPointerException          if the cache configuration or name
   *                                       is null
   * @throws SecurityException             when the operation could not be performed
   *                                       due to the current security settings
   */
  <K, V, C extends Configuration<K, V>> Cache<K, V> createCache(String cacheName,
                                                                C configuration)
      throws IllegalArgumentException;


  /**
   * Looks up a managed {@link Cache} given its name.
   * <p>
   * Use this method to check runtime key and value types.
   * <p>
   * Use {@link #getCache(String)} where this check is not required.
   * <p>
   * Implementations must ensure that the key and value types are the same as
   * those configured for the {@link Cache} prior to returning from this method.
   * <p>
   * Implementations may further perform type checking on mutative cache operations
   * and throw a {@link ClassCastException} if these checks fail.
   * <p>
   * Implementations that support declarative mechanisms for pre-configuring
   * {@link Cache}s may return a pre-configured {@link Cache} instead of
   * <code>null</code>.
   *
   * @param <K> the type of key
   * @param <V> the type of value
   * @param cacheName the name of the managed {@link Cache} to acquire
   * @param keyType   the expected {@link Class} of the key
   * @param valueType the expected {@link Class} of the value
   * @return the Cache or null if it does exist or can't be pre-configured
   * @throws IllegalStateException    if the {@link CacheManager}
   *                                  is {@link #isClosed()}
   * @throws ClassCastException       if the specified key and/or value types are
   *                                  incompatible with the configured cache.
   * @throws NullPointerException     if either keyType or classType is null.
   * @throws SecurityException        when the operation could not be performed
   *                                  due to the current security settings
   */
  <K, V> Cache<K, V> getCache(String cacheName, Class<K> keyType,
                              Class<V> valueType);

  /**
   * Looks up a managed {@link Cache} given its name.
   * <p>
   * This method may only be used to acquire {@link Cache}s that were
   * configured without runtime key and value types, or were configured
   * to use Object.class key and value types.
   * <p>
   * Use the {@link #getCache(String, Class, Class)} method to acquire
   * {@link Cache}s with a check that the supplied key and value type parameters
   * match the runtime types.
   * <p>
   * Implementations that support declarative mechanisms for pre-configuring
   * {@link Cache}s may return a pre-configured {@link Cache} instead of
   * <code>null</code>.
   *
   * @param <K> the type of key
   * @param <V> the type of value
   * @param cacheName the name of the cache to look for
   * @return the Cache or null if it does exist or can't be pre-configured
   * @throws IllegalStateException    if the CacheManager is {@link #isClosed()}
   * @throws SecurityException        when the operation could not be performed
   *                                  due to the current security settings
   * @see #getCache(String, Class, Class)
   */
  <K, V> Cache<K, V> getCache(String cacheName);

  /**
   * Obtains an {@link Iterable} over the names of {@link Cache}s managed by the
   * {@link CacheManager}.
   * <p>
   * {@link java.util.Iterator}s returned by the {@link Iterable} are immutable.
   * If the {@link Cache}s managed by the {@link CacheManager} change,
   * the {@link Iterable} and associated {@link java.util.Iterator}s are not
   * affected.
   * <p>
   * {@link java.util.Iterator}s returned by the {@link Iterable} may not provide
   * all of the {@link Cache}s managed by the {@link CacheManager}.  For example:
   * Internally defined or platform specific {@link Cache}s that may be accessible
   * by a call to {@link #getCache(String)} or {@link #getCache(String, Class,
   * Class)} may not be present in an iteration.
   *
   * @return an {@link Iterable} over the names of managed {@link Cache}s.
   * @throws IllegalStateException if the {@link CacheManager}
   *                               is {@link #isClosed()}
   * @throws SecurityException     when the operation could not be performed
   *                               due to the current security settings
   */
  Iterable<String> getCacheNames();

  /**
   * Destroys a specifically named and managed {@link Cache}.  Once destroyed
   * a new {@link Cache} of the same name but with a different {@link
   * Configuration} may be configured.
   * <p>
   * This is equivalent to the following sequence of method calls:
   * <ol>
   * <li>{@link Cache#clear()}</li>
   * <li>{@link Cache#close()}</li>
   * </ol>
   * followed by allowing the name of the {@link Cache} to be used for other
   * {@link Cache} configurations.
   * <p>
   * From the time this method is called, the specified {@link Cache} is not
   * available for operational use. An attempt to call an operational method on
   * the {@link Cache} will throw an {@link IllegalStateException}.
   *
   * @param cacheName the cache to destroy
   * @throws IllegalStateException if the {@link CacheManager}
   *                               {@link #isClosed()}
   * @throws NullPointerException  if cacheName is null
   * @throws SecurityException     when the operation could not be performed
   *                               due to the current security settings
   */
  void destroyCache(String cacheName);

  /**
   * Controls whether management is enabled. If enabled the {@link CacheMXBean}
   * for each cache is registered in the platform MBean server. The platform
   * MBeanServer is obtained using
   * {@link ManagementFactory#getPlatformMBeanServer()}.
   * <p>
   * Management information includes the name and configuration information for
   * the cache.
   * <p>
   * Each cache's management object must be registered with an ObjectName that
   * is unique and has the following type and attributes:
   * <p>
   * Type:
   * <code>javax.cache:type=CacheConfiguration</code>
   * <p>
   * Required Attributes:
   * <ul>
   * <li>CacheManager the URI of the CacheManager
   * <li>Cache the name of the Cache
   * </ul>
   *
   * @param cacheName the name of the cache to register
   * @param enabled   true to enable management, false to disable.
   * @throws IllegalStateException if the {@link CacheManager} or
   *                               {@link Cache} {@link #isClosed()}
   * @throws SecurityException     when the operation could not be performed
   *                               due to the current security settings
   */
  void enableManagement(String cacheName, boolean enabled);

  /**
   * Enables or disables statistics gathering for a managed {@link Cache} at
   * runtime.
   * <p>
   * Each cache's statistics object must be registered with an ObjectName that
   * is unique and has the following type and attributes:
   * <p>
   * Type:
   * <code>javax.cache:type=CacheStatistics</code>
   * <p>
   * Required Attributes:
   * <ul>
   * <li>CacheManager the URI of the CacheManager
   * <li>Cache the name of the Cache
   * </ul>
   *
   * @param cacheName the name of the cache to register
   * @param enabled   true to enable statistics, false to disable.
   * @throws IllegalStateException if the {@link CacheManager} or
   *                               {@link Cache} {@link #isClosed()}
   * @throws NullPointerException  if cacheName is null
   * @throws SecurityException when the operation could not be performed
   *                           due to the current security settings
   */
  void enableStatistics(String cacheName, boolean enabled);

  /**
   * Closes the {@link CacheManager}.
   * <p>
   * For each {@link Cache} managed by the {@link CacheManager}, the
   * {@link Cache#close()} method will be invoked, in no guaranteed order.
   * <p>
   * If a {@link Cache#close()} call throws an exception, the exception will be
   * ignored.
   * <p>
   * After executing this method, the {@link #isClosed()} method will return
   * <code>true</code>.
   * <p>
   * All attempts to close a previously closed {@link CacheManager} will be
   * ignored.
   *
   * Closing a CacheManager does not necessarily destroy the contents of the
   * Caches in the CacheManager.
   * <p>
   * It simply signals that the CacheManager is no longer required by the application
   * and that future uses of a specific CacheManager instance should not be permitted.
   * <p>
   * Depending on the implementation and Cache topology,
   * (e.g. a storage-backed or distributed cache), the contents of closed Caches
   * previously referenced by the CacheManager, may still be available and accessible
   * by other applications.
   *
   * @throws SecurityException when the operation could not be performed due to the
   *         current security settings
   */
  void close();

  /**
   * Determines whether the {@link CacheManager} instance has been closed. A
   * {@link CacheManager} is considered closed if;
   * <ol>
   * <li>the {@link #close()} method has been called</li>
   * <li>the associated {@link #getCachingProvider()} has been closed, or</li>
   * <li>the {@link CacheManager} has been closed using the associated
   * {@link #getCachingProvider()}</li>
   * </ol>
   * <p>
   * This method generally cannot be called to determine whether the
   * {@link CacheManager} is valid or invalid. A typical client can determine
   * that a {@link CacheManager} is invalid by catching any exceptions that
   * might be thrown when an operation is attempted.
   *
   * @return true if this {@link CacheManager} instance is closed; false if it
   *         is still open
   */
  boolean isClosed();

  /**
   * Provides a standard mechanism to access the underlying concrete caching
   * implementation to provide access to further, proprietary features.
   * <p>
   * If the provider's implementation does not support the specified class,
   * the {@link IllegalArgumentException} is thrown.
   *
   * @param <T> the type of the underlying {@link CacheManager}
   * @param clazz the proprietary class or interface of the underlying concrete
   *              {@link CacheManager}. It is this type that is returned.
   * @return an instance of the underlying concrete {@link CacheManager}
   * @throws IllegalArgumentException if the caching provider doesn't support the
   *                                  specified class.
   * @throws SecurityException        when the operation could not be performed
   *                                  due to the current security settings
   */
  <T> T unwrap(java.lang.Class<T> clazz);
}
```

### 获取默认 `CacheManager`

为了简化 API，开发者可以使用 `Caching` 类提供的默认 `CachingProvider` 类，获取默认的 `CacheManager`。比如

```java
// acquire the default CachingProvider
CachingProvider provider = Caching.getCachingProvider();

// acquire the default CacheManager
CacheManager manager = provider.getCacheManager();
```

为了获取非默认或者说自定义的 `CacheManager`，需要使用 `CachingProvider` 提供的重载版本的 `getCacheManager` 方法。

如何配置一个 `CachingProvider` 会在后面的一节单独介绍。

### 配置 `Cache`

从 `CacheManager` 配置缓存有两种方式。

- `CacheManager` 必须允许应用程序在运行时编程式的配置缓存，通过 `<K, V, C extends Configuration<K, V>> Cache<K, V> createCache(String cacheName, C configuration)` 方法
- `CacheManager` 可以有选择的提供声明式配置来防止在应用程序中使用 `createCache` 方法。

对于缓存实现来说，`CacheManager` 如何实现声明式的配置是自由的，其中一种是通过 XML 文件来配置 `CacheManager` 和其中的缓存。

配置相关的类在 `javax.cache.configuration` 包下。里面提供了最小化配置(`Configuration`)和完整配置(`CompleteConfiguration`)的接口。

尽管此规范提供了一个最小化配置，但是只有完全支持 `CompleteConfiguration` 接口的实现才符合该规范。

`javax.cache.configuration.Configuration` 接口定义如下：

```java
package javax.cache.configuration;

import javax.cache.Cache;
import javax.cache.CacheManager;
import java.io.Serializable;

/**
 * A basic read-only representation of a {@link Cache} configuration.
 * <p>
 * The properties provided by instances of this interface are used by
 * {@link CacheManager}s to configure {@link Cache}s.
 * <p>
 * Implementations of this interface must override {@link Object#hashCode()} and
 * {@link Object#equals(Object)} as {@link Configuration}s are often compared at
 * runtime.
 *
 * @param <K> the type of keys maintained the cache
 * @param <V> the type of cached values
 * @author Greg Luck
 * @author Brian Oliver
 * @since 1.0
 */
public interface Configuration<K, V> extends Serializable {

  /**
   * Determines the required type of keys for {@link Cache}s configured
   * with this {@link Configuration}.
   *
   * @return the key type or <code>Object.class</code> if the type is undefined
   */
  Class<K> getKeyType();

  /**
   * Determines the required type of values for {@link Cache}s configured
   * with this {@link Configuration}.
   *
   * @return the value type or <code>Object.class</code> if the type is undefined
   */
  Class<V> getValueType();

  /**
   * Whether storeByValue (true) or storeByReference (false).
   * When true, both keys and values are stored by value.
   * <p>
   * When false, both keys and values are stored by reference.
   * Caches stored by reference are capable of mutation by any threads holding
   * the reference. The effects are:
   * <ul>
   * <li>if the key is mutated, then the key may not be retrievable or
   * removable</li>
   * <li>if the value is mutated, then all threads in the JVM can potentially
   * observe those mutations, subject to the normal Java Memory Model rules.</li>
   * </ul>
   * Storage by reference only applies to the local heap. If an entry is moved off
   * heap it will need to be transformed into a representation. Any mutations that
   * occur after transformation may not be reflected in the cache.
   * <p>
   * When a cache is storeByValue, any mutation to the key or value does not
   * affect the key of value stored in the cache.
   * <p>
   * The default value is <code>true</code>.
   *
   * @return true if the cache is store by value
   */
  boolean isStoreByValue();
}
```

`javax.cache.configuration.CompleteConfiguration` 接口定义如下：

```java
package javax.cache.configuration;

import javax.cache.expiry.ExpiryPolicy;
import javax.cache.integration.CacheLoader;
import javax.cache.integration.CacheWriter;
import java.io.Serializable;

/**
 * A read-only representation of the complete JCache {@link javax.cache.Cache}
 * configuration.
 * <p>
 * The properties provided by instances of this interface are used by
 * {@link javax.cache.CacheManager}s to configure {@link javax.cache.Cache}s.
 * <p>
 * Implementations of this interface must override {@link Object#hashCode()} and
 * {@link Object#equals(Object)} as
 * {@link javax.cache.configuration.CompleteConfiguration}s are often compared at
 * runtime.
 *
 * @param <K> the type of keys maintained the cache
 * @param <V> the type of cached values
 * @author Greg Luck
 * @author Yannis Cosmadopoulos
 * @author Brian Oliver
 * @since 1.0
 */
public interface CompleteConfiguration<K, V> extends Configuration<K, V>,
    Serializable {

  /**
   * Determines if a {@link javax.cache.Cache} should operate in read-through mode.
   * <p>
   * When in "read-through" mode, cache misses that occur due to cache entries
   * not existing as a result of performing a "get" will appropriately
   * cause the configured {@link javax.cache.integration.CacheLoader} to be
   * invoked.
   * <p>
   * The default value is <code>false</code>.
   *
   * @return <code>true</code> when a {@link javax.cache.Cache} is in
   * "read-through" mode.
   * @see #getCacheLoaderFactory()
   */
  boolean isReadThrough();

  /**
   * Determines if a {@link javax.cache.Cache} should operate in write-through
   * mode.
   * <p>
   * When in "write-through" mode, cache updates that occur as a result of
   * performing "put" operations called via one of
   * {@link javax.cache.Cache#put(Object, Object)},
   * {@link javax.cache.Cache#getAndRemove(Object)},
   * {@link javax.cache.Cache#removeAll()},
   * {@link javax.cache.Cache#getAndPut(Object, Object)}
   * {@link javax.cache.Cache#getAndRemove(Object)},
   * {@link javax.cache.Cache#getAndReplace(Object,
   * Object)}, {@link javax.cache.Cache#invoke(Object,
   * javax.cache.processor.EntryProcessor,
   * Object...)}, {@link javax.cache.Cache#invokeAll(java.util.Set,
   * javax.cache.processor.EntryProcessor, Object...)} will appropriately cause
   * the configured {@link javax.cache.integration.CacheWriter} to be invoked.
   * <p>
   * The default value is <code>false</code>.
   *
   * @return <code>true</code> when a {@link javax.cache.Cache} is in
   *        "write-through" mode.
   * @see #getCacheWriterFactory()
   */
  boolean isWriteThrough();

  /**
   * Checks whether statistics collection is enabled in this cache.
   * <p>
   * The default value is <code>false</code>.
   *
   * @return true if statistics collection is enabled
   */
  boolean isStatisticsEnabled();

  /**
   * Checks whether management is enabled on this cache.
   * <p>
   * The default value is <code>false</code>.
   *
   * @return true if management is enabled
   */
  boolean isManagementEnabled();

  /**
   * Obtains the {@link javax.cache.configuration.CacheEntryListenerConfiguration}s
   * for {@link javax.cache.event.CacheEntryListener}s to be configured on a
   * {@link javax.cache.Cache}.
   *
   * @return an {@link Iterable} over the
   * {@link javax.cache.configuration.CacheEntryListenerConfiguration}s
   */
  Iterable<CacheEntryListenerConfiguration<K,
      V>> getCacheEntryListenerConfigurations();

  /**
   * Gets the {@link javax.cache.configuration.Factory} for the
   * {@link javax.cache.integration.CacheLoader}, if any.
   * <p>
   * A CacheLoader should be configured for "Read Through" caches to load values
   * when a cache miss occurs using either the
   * {@link javax.cache.Cache#get(Object)} and/or
   * {@link javax.cache.Cache#getAll(java.util.Set)} methods.
   * <p>
   * The default value is <code>null</code>.
   *
   * @return the {@link javax.cache.configuration.Factory} for the
   * {@link javax.cache.integration.CacheLoader} or null if none has been set.
   */
  Factory<CacheLoader<K, V>> getCacheLoaderFactory();

  /**
   * Gets the {@link javax.cache.configuration.Factory} for the
   * {@link javax.cache.integration.CacheWriter}, if any.
   * <p>
   * The default value is <code>null</code>.
   *
   * @return the {@link javax.cache.configuration.Factory} for the
   * {@link javax.cache.integration.CacheWriter} or null if none has been set.
   */
  Factory<CacheWriter<? super K, ? super V>> getCacheWriterFactory();

  /**
   * Gets the {@link javax.cache.configuration.Factory} for the
   * {@link javax.cache.expiry.ExpiryPolicy} to be used for caches.
   * <p>
   * The default value is a {@link javax.cache.configuration.Factory} that will
   * produce a {@link javax.cache.expiry.EternalExpiryPolicy} instance.
   *
   * @return the {@link javax.cache.configuration.Factory} for
   * {@link javax.cache.expiry.ExpiryPolicy} (must not be <code>null</code>)
   */
  Factory<ExpiryPolicy> getExpiryPolicyFactory();

}
```

为了方便配置，提供了一个 `javax.cache.configuration.MutableConfiguration` 作为 `CompleteConfiguration` 的实现类。

缓存实现可以提供自定义的 `Configuration` 接口实现来拓展配置。

为了简化 `MutableConfiguration` 的使用，所有 setter 方法都返回 `MutableConfiguration` 的实例。

`CacheManger` 有责任去校验 `Cache` 的配置是否合法，`Cache` 配置可以在创建时被 `CacheManager` 接受，在创建 `Cache` 时抛出 `IllegalArgumentException`。

`MutableConfiguration` 经常使用的构造器和和 setter 方法如下：

```java
/**
   * Default JavaBean constructor.
   * <p>
   * Creates a default configuration. Default configurations have no
   * runtime type checking and are set for eternal expiry.
   * </p><p>
   * To enable runtime type enforcement, if supported by the implementation, call
   * {@link #setTypes} after construction.
   * </p><p>
   * After construction set any other configuration parameters in the
   * fluent style. e.g.
   * </p>
   * <pre>{@code
   * CacheConfiguration<Integer, String> = new MutableConfiguration<Integer, String>()
   *         .setTypes(Integer.class, String.class)
   *         .setReadThrough(true)
   *         . . .
   * }</pre>
   * @see #setTypes(Class, Class)
   */
  public MutableConfiguration()

  /**
   * Constructs a {@link MutableConfiguration} based on another
   * {@link CompleteConfiguration}.
   *
   * @param configuration the {@link CompleteConfiguration}
   */
  public MutableConfiguration(CompleteConfiguration<K, V> configuration)

  /**
   * Sets the expected type of keys and values for a {@link Cache}
   * configured with this {@link Configuration}. Setting both to
   * <code>Object.class</code> means type-safety checks are not required.
* <p>
   * This is used by {@link CacheManager} to ensure that the key and value
   * types are the same as those configured for the {@link Cache} prior to
   * returning a requested cache from this method.
   * <p>
   * Implementations may further perform type checking on mutative cache operations
   * and throw a {@link ClassCastException} if these checks fail.
   *
   * @param keyType   the expected key type
   * @param valueType the expected value type
   * @return the {@link MutableConfiguration} to permit fluent-style method calls
   * @throws NullPointerException should the key or value type be null
   * @see CacheManager#getCache(String, Class, Class)
   */
  public MutableConfiguration<K, V> setTypes(Class<K> keyType, Class<V> valueType)


  /**
   * Add a configuration for a {@link CacheEntryListener}.
   *
   * @param cacheEntryListenerConfiguration the
   *  {@link CacheEntryListenerConfiguration}
   * @return the {@link MutableConfiguration} to permit fluent-style method calls
   * @throws IllegalArgumentException is the same CacheEntryListenerConfiguration
   * is used more than once
   */
  public MutableConfiguration<K, V> addCacheEntryListenerConfiguration(
      CacheEntryListenerConfiguration<K, V> cacheEntryListenerConfiguration)


  /**
   * Remove a configuration for a {@link CacheEntryListener}.
   *
   * @param cacheEntryListenerConfiguration  the
   *     {@link CacheEntryListenerConfiguration} to remove
   * @return the {@link MutableConfiguration} to permit fluent-style method calls
   */
  public MutableConfiguration<K, V> removeCacheEntryListenerConfiguration(
      CacheEntryListenerConfiguration<K, V> cacheEntryListenerConfiguration)


  /**
   * Set the {@link CacheLoader} factory.
   *
   * @param factory the {@link CacheLoader} {@link Factory}
   * @return the {@link MutableConfiguration} to permit fluent-style method calls
   */
  public MutableConfiguration<K, V> setCacheLoaderFactory(Factory<? extends
      CacheLoader<K, V>> factory)

  /**
   * Set the {@link CacheWriter} factory.
   *
 * @param factory the {@link CacheWriter} {@link Factory}
   * @return the {@link MutableConfiguration} to permit fluent-style method calls
   */
  public MutableConfiguration<K, V> setCacheWriterFactory(Factory<? extends
      CacheWriter<? super K, ? super V>> factory)

  /**
   * Set the {@link Factory} for the {@link ExpiryPolicy}.  If <code>null</code>
   * is specified the default {@link ExpiryPolicy} is used.
   * <p>
   * Only one expiry policy can be set for a cache. The last policy applied
   * before cache construction will be the one used.
   * @param factory the {@link ExpiryPolicy} {@link Factory}
   * @return the {@link MutableConfiguration} to permit fluent-style method calls
   */
  public MutableConfiguration<K, V> setExpiryPolicyFactory(Factory<? extends
      ExpiryPolicy> factory)

  /**
   * Set if read-through caching should be used.
   * <p>
   * It is an invalid configuration to set this to true without specifying a
   * {@link CacheLoader} {@link Factory}.
   *
   * @param isReadThrough <code>true</code> if read-through is required
   * @return the {@link MutableConfiguration} to permit fluent-style method calls
   */
  public MutableConfiguration<K, V> setReadThrough(boolean isReadThrough)


  /**
   * Set if write-through caching should be used.
   * <p>
   * It is an invalid configuration to set this to true without specifying a
   * {@link CacheWriter} {@link Factory}.
   *
   * @param isWriteThrough <code>true</code> if write-through is required
   * @return the {@link MutableConfiguration} to permit fluent-style method calls
   */
  public MutableConfiguration<K, V> setWriteThrough(boolean isWriteThrough)


  /**
   * Set if a configured cache should use store-by-value or store-by-reference
   * semantics.
   *
   * @param isStoreByValue <code>true</code> if store-by-value is required,
   *                       <code>false</code> for store-by-reference
   * @return the {@link MutableConfiguration} to permit fluent-style method calls
   */
  public MutableConfiguration<K, V> setStoreByValue(boolean isStoreByValue)

  /**
   * Sets whether statistics gathering is enabled on a cache.
   * <p>
   * Statistics may be enabled or disabled at runtime via
   * {@link CacheManager#enableStatistics(String, boolean)}.
   *
   * @param enabled true to enable statistics, false to disable.
   * @return the {@link MutableConfiguration} to permit fluent-style method calls
   */
  public MutableConfiguration<K, V> setStatisticsEnabled(boolean enabled)

  /**
   * Sets whether management is enabled on a cache.
   * <p>
   * Management may be enabled or disabled at runtime via
   * {@link CacheManager#enableManagement(String, boolean)}.
   *
   * @param enabled true to enable statistics, false to disable.
   * @return the {@link MutableConfiguration} to permit fluent-style method calls
   */
  public MutableConfiguration<K, V> setManagementEnabled(boolean enabled)


```

`MutableConfiguration` 中提供的配置和 `Configuration` 会在后面的章节中深入讨论。

下表是一个 `MutableConfiguration` 实例所提供的默认值。

|配置项|类型|默认值|
|---|---|---|
|Key 类型|`Class<?>`|`Object.class`|
|Value 类型|`Class<?>`|`Object.class`|
|Cache Loader Factory|`Factory<CacheLoader<K, V>>`|`null`|
|Cache Writer Factory|`Factory<CacheWriter<? super K, ? super V>>`|`null`|
|Expiry Policy Factory|`Factory<ExpiryPolicy<K>>`|`a factory producing an EternalExpiryPolicy`|
|Read Through Enabled|`boolean`|`false`|
|Write Through Enabled|`boolean`|`false`|
|Cache Entry Listener Configuration|`Iterable<CacheEntryListenerConfiguration<? super K, ? super V>>`|`an empty iteration`|
|Statistics Enabled|`boolean`|`false`|
|Management Enabled|`boolean`|`false`|

### 缓存名和缓存作用域

对于每一个 `Cache`，在创建该 `Cache` 的 `CacheManager` 的作用域内，由 缓存名 唯一确定

因为缓存名作为 Java String 存在，所以就可移植性来说，有如下限制和推荐的命名规定

- `java.` 或 `javax.` 开头的缓存名不能使用。因为可能作为平台级的缓存名前缀。
- 缓存名不能包含 `/` 和 `:`，因为可能被用于 Java EE 环境中基于 JNDI 查询。
- 缓存名可以使用 Unicode 字符

虽然不是必须的，应用程序恶意使用要缓存的 `Value` 类的全类名作为缓存名，比如 缓存 Orders 的缓存可以叫 `com.mycompany.Orders`。

### 获取缓存

目前有两种方式从 `CacheManager` 中获取缓存。

- 当需要一个类型安全的 `Cache` 时，应该使用 `CacheManger` 提供的 `<K, V> Cache<K, V> getCache(String cacheName,Class<K> keyType, Class<V> valueType)`。
- 当不需要类型安全校验时（由应用自己来确保），应该使用 `<K, V> Cache<K, V> Cache getCache(String cacheName);`

可以查阅 缓存类型安全 一节来获得相关的更多信息。

一个简单的获取缓存的例子：

```java
Cache<String, Integer> cache = cacheManager.getCache(
        "simpleCache", String.class, Integer.class);
```

### `Cache` 和 `CacheManager` 的生命周期

所有 `Cache` 和 `CacheManager` 实例只有两个状态，`opened` 和 `closed`，当打开时，所有操作都是允许的，包括创建、更新、删除条目或配置、获取、关闭、删除缓存等。当关闭时，所有操作都会抛出 `IllegalStateException`。

### 关闭缓存

通过调用 `Cache.close()` 方法关闭 `Cache` 会向创建或拥有该 `Cache` 的 `CacheManager` 发出信号，表明不应再对其进行管理。在次数，`CacheManger` 做了如下操作：

- 必须关闭和释放与该缓存相关的所有资源。这包括调用 `CacheLoader`、`CacheWriter`、`CacheEntryListener`、`ExpiryPolicy` 实例的 `close` 方法。
- 不再传递事件给该 `Cache` 的 `CacheEntryListener`。
- 当调用 `CacheManager getCacheNames()` 时，不再返回该缓存的名字。

一旦缓存关闭后，所有对缓存的操作都会抛出 `IllegalStateException`，以下是操作方法：

```java
- clear
- containsKey
- deregisterCacheEntryListener
- get
- getAll
- getAndPut
- getAndRemove
- getAndReplace
- invoke
- invokeAll
- iterator
- loadAll
- put
- putAll
- putIfAbsent
- registerCacheEntryListener
- remove
- removeAll
- replace
```

关闭缓存并不一定必须要销毁缓存的所有内容。它仅仅是向拥有它的 `CacheManager` 发出信号。表示应用程序已经不再需要该缓存且不允许对该缓存做任何操作。根据实现的不同（基于存储或分布式），已关闭的缓存内容可能仍然可以被【其他】应用程序访问，不管是在关闭之前获取到的还是在关闭之后获取到的。

### 销毁缓存

要销毁一个 `Cache`，将其从被管理的状态中释放出来，并删除所有缓存条目，从而允许创建一个具有相同名称但可能具有不同配置的新缓存，应调用 `CacheManager destroyCache` 方法。

```java
/**
 * Destroys a specifically named and managed {@link Cache}.  Once destroyed
 * a new {@link Cache} of the same name but with a different {@link
 * Configuration} may be configured.
 * <p>
 * This is equivalent to the following sequence of method calls:
 * <ol>
 * <li>{@link Cache#clear()}</li>
 * <li>{@link Cache#close()}</li>
 * </ol>
 * followed by allowing the name of the {@link Cache} to be used for other
 * {@link Cache} configurations.
 * <p>
 * From the time this method is called, the specified {@link Cache} is not
 * available for operational use. An attempt to call an operational method on
 * the {@link Cache} will throw an {@link IllegalStateException}.
 *
 * @param cacheName the cache to destroy
 * @throws IllegalStateException if the {@link CacheManager}
 *                               {@link #isClosed()}
 * @throws NullPointerException  if cacheName is null
 * @throws SecurityException     when the operation could not be performed
 *                               due to the current security settings
 */
void destroyCache(String cacheName);
```

一旦被销毁：

- 任何试图操作操作该缓存的方法调用将抛出 `IllegalStateException`
- 被销毁的缓存的名字可以被新缓存重用，跟之前的区别是配置不同。

一旦销毁，就无法通过 `CacheManager` 使用缓存。 销毁缓存可确保关闭缓存，并且无论应用程序或拓扑如何，所有应用程序都将立即或将来不再使用所有关联条目。

### 关闭 `CacheManager`

可以通过 `CacheManager.close()` 或者 `CachingProvider.close(...)` 方法来关闭 `CacheManager`，这两个方法调用会有如下效果：

- 关闭被其管理的所有 `Cache`。
- 释放用来管理 `Cache` 的所有资源。
- 一旦关闭，任何试图操作 `CacheManager` 或其管理的 `Cache` 的行为都将抛出 `IllegalStateException`，其中涉及的方法如下：

```java
- createCache
- destroyCache
- enableManagement
- enableStatistics
- getCache
- getCacheNames
```

关闭 `CacheManager` 后，可以使用最初创建 `CacheManager` 的 `CachingProvider` 创建另外一个实例。这部分将在 `CachingProvder` 部分进行介绍。

关闭 `CacheManager` 并不一定会销毁 `CacheManager` 中 `Cache` 里的数据。 它只是表明应用程序不再需要拥有的`CacheManager`，并且不应再允许该特定 `CacheManager` 实例的将来使用。 取决于实现（基于存储或分布式），已关闭的`CacheManager` 管理的 `Cache`的数据可能仍然可以被【其他】应用程序访问。

### 类加载

同一个 `CacheManager` 中的所有 `Cache` 共用用于创建 `CacheManager` 的类加载器。

如果不同的 `Cache` 要使用不同的类加载器，则必须通过创建不同的 `CacheManager` 实现。有关如何配置 `CacheManager` 的信息，请参阅关于 `CachingProvider` 的部分。

## `Cache`

开发者主要通过 `javax.cache.Cache` 与 `Cache` 进行交互。

`javax.cache.Cache` 接口提供了 Map-like 的方法来访问、更新、删除缓存条目。

`javax.cache.Cache` 接口定义如下：

```java
import javax.cache.configuration.CacheEntryListenerConfiguration;
import javax.cache.configuration.Configuration;
import javax.cache.event.CacheEntryListener;
import javax.cache.event.CacheEntryRemovedListener;
import javax.cache.expiry.ExpiryPolicy;
import javax.cache.integration.CacheLoader;
import javax.cache.integration.CacheWriter;
import javax.cache.integration.CompletionListener;
import javax.cache.processor.EntryProcessor;
import javax.cache.processor.EntryProcessorException;
import javax.cache.processor.EntryProcessorResult;
import java.io.Closeable;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

/**
 * A {@link Cache} is a Map-like data structure that provides temporary storage
 * of application data.
 * <p>
 * Like {@link Map}s, {@link Cache}s
 * <ol>
 * <li>store key-value pairs, each referred to as an {@link Entry}</li>
 * <li>allow use of Java Generics to improve application type-safety</li>
 * <li>are {@link Iterable}</li>
 * </ol>
 * <p>
 * Unlike {@link Map}s, {@link Cache}s
 * <ol>
 * <li>do not allow null keys or values.  Attempts to use <code>null</code>
 * will result in a {@link NullPointerException}</li>
 * <li>provide the ability to read values from a
 * {@link CacheLoader} (read-through-caching)
 * when a value being requested is not in a cache</li>
 * <li>provide the ability to write values to a
 * {@link CacheWriter} (write-through-caching)
 * when a value being created/updated/removed from a cache</li>
 * <li>provide the ability to observe cache entry changes</li>
 * <li>may capture and measure operational statistics</li>
 * </ol>
 * <p>
 * A simple example of how to use a cache is:
 * <pre><code>
 * String cacheName = "sampleCache";
 * CachingProvider provider = Caching.getCachingProvider();
 * CacheManager manager = provider.getCacheManager();
 * Cache&lt;Integer, Date&gt; cache = manager.getCache(cacheName, Integer.class,
 *                                                     Date.class);
 * Date value1 = new Date();
 * Integer key = 1;
 * cache.put(key, value1);
 * Date value2 = cache.get(key);
 * </code></pre>
 *
 * @param <K> the type of key
 * @param <V> the type of value
 * @author Greg Luck
 * @author Yannis Cosmadopoulos
 * @author Brian Oliver
 * @since 1.0
 */
public interface Cache<K, V> extends Iterable<Cache.Entry<K, V>>, Closeable {
    /**
     * Gets an entry from the cache.
     * <p>
     * If the cache is configured to use read-through, and get would return null
     * because the entry is missing from the cache, the Cache's {@link CacheLoader}
     * is called in an attempt to load the entry.
     *
     * @param key the key whose associated value is to be returned
     * @return the element, or null, if it does not exist.
     * @throws IllegalStateException if the cache is {@link #isClosed()}
     * @throws NullPointerException  if the key is null
     * @throws CacheException        if there is a problem fetching the value
     * @throws ClassCastException    if the implementation is configured to perform
     *                               runtime-type-checking, and the key or value
     *                               types are incompatible with those that have been
     *                               configured for the {@link Cache}
     */
    V get(K key);

    /**
     * Gets a collection of entries from the {@link Cache}, returning them as
     * {@link Map} of the values associated with the set of keys requested.
     * <p>
     * If the cache is configured read-through, and a get for a key would
     * return null because an entry is missing from the cache, the Cache's
     * {@link CacheLoader} is called in an attempt to load the entry. If an
     * entry cannot be loaded for a given key, the key will not be present in
     * the returned Map.
     *
     * @param keys The keys whose associated values are to be returned.
     * @return A map of entries that were found for the given keys. Keys not found
     *         in the cache are not in the returned map.
     * @throws NullPointerException  if keys is null or if keys contains a null
     * @throws IllegalStateException if the cache is {@link #isClosed()}
     * @throws CacheException        if there is a problem fetching the values
     * @throws ClassCastException    if the implementation is configured to perform
     *                               runtime-type-checking, and the key or value
     *                               types are incompatible with those that have been
     *                               configured for the {@link Cache}
     */
    Map<K, V> getAll(Set<? extends K> keys);

    /**
     * Determines if the {@link Cache} contains an entry for the specified key.
     * <p>
     * More formally, returns <tt>true</tt> if and only if this cache contains a
     * mapping for a key <tt>k</tt> such that <tt>key.equals(k)</tt>.
     * (There can be at most one such mapping.)</p>
     * <p>
     * If the cache is configured read-through the associated {@link CacheLoader}
     * is not called. Only the cache is checked.
     * </p>
     * @param key key whose presence in this cache is to be tested.
     * @return <tt>true</tt> if this map contains a mapping for the specified key
     * @throws NullPointerException  if key is null
     * @throws IllegalStateException if the cache is {@link #isClosed()}
     * @throws CacheException        it there is a problem checking the mapping
     * @throws ClassCastException    if the implementation is configured to perform
     *                               runtime-type-checking, and the key or value
     *                               types are incompatible with those that have been
     *                               configured for the {@link Cache}
     * @see java.util.Map#containsKey(Object)
     */
    boolean containsKey(K key);

    /**
     * Asynchronously loads the specified entries into the cache using the
     * configured {@link CacheLoader} for the given keys.
     * <p>
     * If an entry for a key already exists in the Cache, a value will be loaded
     * if and only if <code>replaceExistingValues</code> is true.   If no loader
     * is configured for the cache, no objects will be loaded.  If a problem is
     * encountered during the retrieving or loading of the objects,
     * an exception is provided to the {@link CompletionListener}.  Once the
     * operation has completed, the specified CompletionListener is notified.
     * <p>
     * Implementations may choose to load multiple keys from the provided
     * {@link Set} in parallel.  Iteration however must not occur in parallel,
     * thus allow for non-thread-safe {@link Set}s to be used.
     * <p>
     * The thread on which the completion listener is called is implementation
     * dependent. An implementation may also choose to serialize calls to
     * different CompletionListeners rather than use a thread per
     * CompletionListener.
     *
     * @param keys                  the keys to load
     * @param replaceExistingValues when true existing values in the Cache will
     *                              be replaced by those loaded from a CacheLoader
     * @param completionListener    the CompletionListener (may be null)
     * @throws NullPointerException  if keys is null or if keys contains a null.
     * @throws IllegalStateException if the cache is {@link #isClosed()}
     * @throws CacheException        thrown if there is a problem performing the
     *                               load. This may also be thrown on calling if
     *                               there are insufficient threads available to
     *                               perform the load.
     * @throws ClassCastException    if the implementation is configured to perform
     *                               runtime-type-checking, and the key or value
     *                               types are incompatible with those that have been
     *                               configured for the {@link Cache}
     */
    void loadAll(Set<? extends K> keys, boolean replaceExistingValues,
                 CompletionListener completionListener);

    /**
     * Associates the specified value with the specified key in the cache.
     * <p>
     * If the {@link Cache} previously contained a mapping for the key, the old
     * value is replaced by the specified value.  (A cache <tt>c</tt> is said to
     * contain a mapping for a key <tt>k</tt> if and only if {@link
     * #containsKey(Object) c.containsKey(k)} would return <tt>true</tt>.)
     * <p>
     * If the cache is configured write-through the
     * {@link CacheWriter#write(Cache.Entry)} method will be called.
     * </p>
     *
     * @param key   key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @throws NullPointerException  if key is null or if value is null
     * @throws IllegalStateException if the cache is {@link #isClosed()}
     * @throws CacheException        if there is a problem doing the put
     * @throws ClassCastException    if the implementation is configured to perform
     *                               runtime-type-checking, and the key or value
     *                               types are incompatible with those that have been
     *                               configured for the {@link Cache}
     * @see java.util.Map#put(Object, Object)
     * @see #getAndPut(Object, Object)
     * @see #getAndReplace(Object, Object)
     * @see CacheWriter#write
     */
    void put(K key, V value);

    /**
     * Associates the specified value with the specified key in this cache,
     * returning an existing value if one existed.
     * <p>
     * If the cache previously contained a mapping for
     * the key, the old value is replaced by the specified value.  (A cache
     * <tt>c</tt> is said to contain a mapping for a key <tt>k</tt> if and only
     * if {@link #containsKey(Object) c.containsKey(k)} would return
     * <tt>true</tt>.)
     * <p>
     * The previous value is returned, or null if there was no value associated
     * with the key previously.</p>
     * <p>
     * If the cache is configured write-through the associated
     * {@link CacheWriter#write(Cache.Entry)} method will be called.
     * </p>
     *
     * @param key   key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @return the value associated with the key at the start of the operation or
     *         null if none was associated
     * @throws NullPointerException  if key is null or if value is null
     * @throws IllegalStateException if the cache is {@link #isClosed()}
     * @throws CacheException        if there is a problem doing the put
     * @throws ClassCastException    if the implementation is configured to perform
     *                               runtime-type-checking, and the key or value
     *                               types are incompatible with those that have been
     *                               configured for the {@link Cache}
     * @see #put(Object, Object)
     * @see #getAndReplace(Object, Object)
     * @see CacheWriter#write(Cache.Entry)
     */
    V getAndPut(K key, V value);

    /**
     * Copies all of the entries from the specified map to the {@link Cache}.
     * <p>
     * The effect of this call is equivalent to that of calling
     * {@link #put(Object, Object) put(k, v)} on this cache once for each mapping
     * from key <tt>k</tt> to value <tt>v</tt> in the specified map.
     * <p>
     * The order in which the individual puts occur is undefined.
     * <p>
     * The behavior of this operation is undefined if entries in the cache
     * corresponding to entries in the map are modified or removed while this
     * operation is in progress. or if map is modified while the operation is in
     * progress.
     * <p>
     * In Default Consistency mode, individual puts occur atomically but not
     * the entire putAll.  Listeners may observe individual updates.
     * <p>
     * If the cache is configured write-through the associated
     * {@link CacheWriter#writeAll} method will be called.
     * </p>
     *
     * @param map mappings to be stored in this cache
     * @throws NullPointerException  if map is null or if map contains null keys
     *                               or values.
     * @throws IllegalStateException if the cache is {@link #isClosed()}
     * @throws CacheException        if there is a problem doing the put.
     * @throws ClassCastException    if the implementation is configured to perform
     *                               runtime-type-checking, and the key or value
     *                               types are incompatible with those that have been
     *                               configured for the {@link Cache}
     * @see CacheWriter#writeAll
     */
    void putAll(java.util.Map<? extends K, ? extends V> map);

    /**
     * Atomically associates the specified key with the given value if it is
     * not already associated with a value.
     * <p>
     * This is equivalent to:
     * <pre><code>
     * if (!cache.containsKey(key)) {}
     *   cache.put(key, value);
     *   return true;
     * } else {
     *   return false;
     * }
     * </code></pre>
     * except that the action is performed atomically.
     * <p>
     * If the cache is configured write-through, and this method returns true,
     * the associated {@link CacheWriter#write(Cache.Entry)} method will be called.
     * </p>
     * @param key   key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @return true if a value was set.
     * @throws NullPointerException  if key is null or value is null
     * @throws IllegalStateException if the cache is {@link #isClosed()}
     * @throws CacheException        if there is a problem doing the put
     * @throws ClassCastException    if the implementation is configured to perform
     *                               runtime-type-checking, and the key or value
     *                               types are incompatible with those that have been
     *                               configured for the {@link Cache}
     * @see CacheWriter#write
     */
    boolean putIfAbsent(K key, V value);

    /**
     * Removes the mapping for a key from this cache if it is present.
     * <p>
     * More formally, if this cache contains a mapping from key <tt>k</tt> to
     * value <tt>v</tt> such that
     * <code>(key==null ?  k==null : key.equals(k))</code>, that mapping is removed.
     * (The cache can contain at most one such mapping.)
     *
     * <p>Returns <tt>true</tt> if this cache previously associated the key,
     * or <tt>false</tt> if the cache contained no mapping for the key.
     * <p>
     * The cache will not contain a mapping for the specified key once the
     * call returns.
     * <p>
     * If the cache is configured write-through the associated
     * {@link CacheWriter#delete(Object)} method will be called.
     * </p>
     * @param key key whose mapping is to be removed from the cache
     * @return returns false if there was no matching key
     * @throws NullPointerException  if key is null
     * @throws IllegalStateException if the cache is {@link #isClosed()}
     * @throws CacheException        if there is a problem doing the remove
     * @throws ClassCastException    if the implementation is configured to perform
     *                               runtime-type-checking, and the key or value
     *                               types are incompatible with those that have been
     *                               configured for the {@link Cache}
     * @see CacheWriter#delete
     */
    boolean remove(K key);

    /**
     * Atomically removes the mapping for a key only if currently mapped to the
     * given value.
     * <p>
     * This is equivalent to:
     * <pre><code>
     * if (cache.containsKey(key) &amp;&amp; equals(cache.get(key), oldValue) {
     *   cache.remove(key);
     *   return true;
     * } else {
     *   return false;
     * }
     * </code></pre>
     * except that the action is performed atomically.
     * <p>
     * If the cache is configured write-through, and this method returns true,
     * the associated {@link CacheWriter#delete(Object)} method will be called.
     * </p>
     * @param key      key whose mapping is to be removed from the cache
     * @param oldValue value expected to be associated with the specified key
     * @return returns false if there was no matching key
     * @throws NullPointerException  if key is null
     * @throws IllegalStateException if the cache is {@link #isClosed()}
     * @throws CacheException        if there is a problem doing the remove
     * @throws ClassCastException    if the implementation is configured to perform
     *                               runtime-type-checking, and the key or value
     *                               types are incompatible with those that have been
     *                               configured for the {@link Cache}
     * @see CacheWriter#delete
     */
    boolean remove(K key, V oldValue);

    /**
     * Atomically removes the entry for a key only if currently mapped to some
     * value.
     * <p>
     * This is equivalent to:
     * <pre><code>
     * if (cache.containsKey(key)) {
     *   V oldValue = cache.get(key);
     *   cache.remove(key);
     *   return oldValue;
     * } else {
     *   return null;
     * }
     * </code></pre>
     * except that the action is performed atomically.
     * <p>
     * If the cache is configured write-through the associated
     * {@link CacheWriter#delete(Object)} method will be called.
     * </p>
     *
     * @param key key with which the specified value is associated
     * @return the value if one existed or null if no mapping existed for this key
     * @throws NullPointerException  if the specified key or value is null.
     * @throws IllegalStateException if the cache is {@link #isClosed()}
     * @throws CacheException        if there is a problem during the remove
     * @throws ClassCastException    if the implementation is configured to perform
     *                               runtime-type-checking, and the key or value
     *                               types are incompatible with those that have been
     *                               configured for the {@link Cache}
     * @see CacheWriter#delete
     */
    V getAndRemove(K key);

    /**
     * Atomically replaces the entry for a key only if currently mapped to a
     * given value.
     * <p>
     * This is equivalent to:
     * <pre><code>
     * if (cache.containsKey(key) &amp;&amp; equals(cache.get(key), oldValue)) {
     *  cache.put(key, newValue);
     * return true;
     * } else {
     *  return false;
     * }
     * </code></pre>
     * except that the action is performed atomically.
     * <p>
     * If the cache is configured write-through, and this method returns true,
     * the associated {@link CacheWriter#write(Cache.Entry)} method will be called.
     * </p>
     * @param key      key with which the specified value is associated
     * @param oldValue value expected to be associated with the specified key
     * @param newValue value to be associated with the specified key
     * @return <tt>true</tt> if the value was replaced
     * @throws NullPointerException  if key is null or if the values are null
     * @throws IllegalStateException if the cache is {@link #isClosed()}
     * @throws CacheException        if there is a problem during the replace
     * @throws ClassCastException    if the implementation is configured to perform
     *                               runtime-type-checking, and the key or value
     *                               types are incompatible with those that have been
     *                               configured for the {@link Cache}
     * @see CacheWriter#write
     */
    boolean replace(K key, V oldValue, V newValue);

    /**
     * Atomically replaces the entry for a key only if currently mapped to some
     * value.
     * <p>
     * This is equivalent to
     * <pre><code>
     * if (cache.containsKey(key)) {
     *   cache.put(key, value);
     *   return true;
     * } else {
     *   return false;
     * }</code></pre>
     * except that the action is performed atomically.
     * <p>
     * If the cache is configured write-through, and this method returns true,
     * the associated {@link CacheWriter#write(Cache.Entry)} method will be called.
     * </p>
     * @param key  the key with which the specified value is associated
     * @param value the value to be associated with the specified key
     * @return <tt>true</tt> if the value was replaced
     * @throws NullPointerException  if key is null or if value is null
     * @throws IllegalStateException if the cache is {@link #isClosed()}
     * @throws CacheException        if there is a problem during the replace
     * @throws ClassCastException    if the implementation is configured to perform
     *                               runtime-type-checking, and the key or value
     *                               types are incompatible with those that have been
     *                               configured for the {@link Cache}
     * @see #getAndReplace(Object, Object)
     * @see CacheWriter#write
     */
    boolean replace(K key, V value);

    /**
     * Atomically replaces the value for a given key if and only if there is a
     * value currently mapped by the key.
     * <p>
     * This is equivalent to
     * <pre><code>
     * if (cache.containsKey(key)) {
     *   V oldValue = cache.get(key);
     *   cache.put(key, value);
     *   return oldValue;
     * } else {
     *   return null;
     * }
     * </code></pre>
     * except that the action is performed atomically.
     * <p>
     * If the cache is configured write-through, and this method returns true,
     * the associated {@link CacheWriter#write(Cache.Entry)} method will be called.
     * </p>
     * @param key   key with which the specified value is associated
     * @param value value to be associated with the specified key
     * @return the previous value associated with the specified key, or
     *         <tt>null</tt> if there was no mapping for the key.
     * @throws NullPointerException  if key is null or if value is null
     * @throws IllegalStateException if the cache is {@link #isClosed()}
     * @throws CacheException        if there is a problem during the replace
     * @throws ClassCastException    if the implementation is configured to perform
     *                               runtime-type-checking, and the key or value
     *                               types are incompatible with those that have been
     *                               configured for the {@link Cache}
     * @see java.util.concurrent.ConcurrentMap#replace(Object, Object)
     * @see CacheWriter#write
     */
    V getAndReplace(K key, V value);

    /**
     * Removes entries for the specified keys.
     * <p>
     * The order in which the individual entries are removed is undefined.
     * <p>
     * For every entry in the key set, the following are called:
     * <ul>
     *   <li>any registered {@link CacheEntryRemovedListener}s</li>
     *   <li>if the cache is a write-through cache, the {@link CacheWriter}</li>
     * </ul>
     *
     * @param keys the keys to remove
     * @throws NullPointerException  if keys is null or if it contains a null key
     * @throws IllegalStateException if the cache is {@link #isClosed()}
     * @throws CacheException        if there is a problem during the remove
     * @throws ClassCastException    if the implementation is configured to perform
     *                               runtime-type-checking, and the key or value
     *                               types are incompatible with those that have been
     *                               configured for the {@link Cache}
     * @see CacheWriter#deleteAll
     */
    void removeAll(Set<? extends K> keys);

    /**
     * Removes all of the mappings from this cache.
     * <p>
     * The order that the individual entries are removed is undefined.
     * <p>
     * For every mapping that exists the following are called:
     * <ul>
     *   <li>any registered {@link CacheEntryRemovedListener}s</li>
     *   <li>if the cache is a write-through cache, the {@link CacheWriter}</li>
     * </ul>
     * If the cache is empty, the {@link CacheWriter} is not called.
     * <p>
     * This is potentially an expensive operation as listeners are invoked.
     * Use {@link #clear()} to avoid this.
     *
     * @throws IllegalStateException if the cache is {@link #isClosed()}
     * @throws CacheException        if there is a problem during the remove
     * @see #clear()
     * @see CacheWriter#deleteAll
     */
    void removeAll();

    /**
     * Clears the contents of the cache, without notifying listeners or
     * {@link CacheWriter}s.
     *
     * @throws IllegalStateException if the cache is {@link #isClosed()}
     * @throws CacheException        if there is a problem during the clear
     */
    void clear();

    /**
     * Provides a standard way to access the configuration of a cache using
     * JCache configuration or additional proprietary configuration.
     * <p>
     * The returned value must be immutable.
     * <p>
     * If the provider's implementation does not support the specified class,
     * the {@link IllegalArgumentException} is thrown.
     *
     * @param <C> the type of the Configuration
     * @param clazz the configuration interface or class to return. This includes
     *              {@link Configuration}.class and
     *              {@link javax.cache.configuration.CompleteConfiguration}s.
     * @return the requested implementation of {@link Configuration}
     * @throws IllegalArgumentException if the caching provider doesn't support
     *                                  the specified class.
     */
    <C extends Configuration<K, V>> C getConfiguration(Class<C> clazz);

    /**
     * Invokes an {@link EntryProcessor} against the {@link Entry} specified by
     * the provided key.
     *
     * @param <T>            the type of the return value
     * @param key            the key to the entry
     * @param entryProcessor the {@link EntryProcessor} to invoke
     * @param arguments      additional arguments to pass to the
     *                       {@link EntryProcessor}
     * @return the result of the processing, if any, defined by the
     *         {@link EntryProcessor} implementation
     * @throws NullPointerException    if key or {@link EntryProcessor} is null
     * @throws IllegalStateException   if the cache is {@link #isClosed()}
     * @throws ClassCastException    if the implementation is configured to perform
     *                               runtime-type-checking, and the key or value
     *                               types are incompatible with those that have been
     *                               configured for the {@link Cache}
     * @throws EntryProcessorException if an exception is thrown by the {@link
     *                                 EntryProcessor}, a Caching Implementation
     *                                 must wrap any {@link Exception} thrown
     *                                 wrapped in an {@link EntryProcessorException}.
     * @see EntryProcessor
     */
    <T> T invoke(K key,
                 EntryProcessor<K, V, T> entryProcessor,
                 Object... arguments) throws EntryProcessorException;

    /**
     * Invokes an {@link EntryProcessor} against the set of {@link Entry}s
     * specified by the set of keys.
     * <p>
     * The order that the entries for the keys are processed is undefined.
     * Implementations may choose to process the entries in any order, including
     * concurrently.  Furthermore there is no guarantee implementations will
     * use the same {@link EntryProcessor} instance to process each entry, as
     * the case may be in a non-local cache topology.
     * <p>
     * The result of executing the {@link EntryProcessor} is returned as a
     * {@link Map} of {@link EntryProcessorResult}s, one result per key.  Should the
     * {@link EntryProcessor} or Caching implementation throw an exception, the
     * exception is wrapped and re-thrown when a call to
     * {@link javax.cache.processor.EntryProcessorResult#get()} is made.
     *
     * @param <T>            the type of the return value
     * @param keys           the set of keys for entries to process
     * @param entryProcessor the {@link EntryProcessor} to invoke
     * @param arguments      additional arguments to pass to the
     *                       {@link EntryProcessor}
     * @return the map of {@link EntryProcessorResult}s of the processing per key,
     * if any, defined by the {@link EntryProcessor} implementation.  No mappings
     * will be returned for {@link EntryProcessor}s that return a
     * <code>null</code> value for a key.
     * @throws NullPointerException    if keys or {@link EntryProcessor} are null
     * @throws IllegalStateException   if the cache is {@link #isClosed()}
     * @throws ClassCastException    if the implementation is configured to perform
     *                               runtime-type-checking, and the key or value
     *                               types are incompatible with those that have been
     *                               configured for the {@link Cache}
     * @see EntryProcessor
     */
    <T> Map<K, EntryProcessorResult<T>> invokeAll(Set<? extends K> keys,
                                                  EntryProcessor<K, V, T>
                                                          entryProcessor,
                                                  Object... arguments);

    /**
     * Return the name of the cache.
     *
     * @return the name of the cache.
     */
    String getName();

    /**
     * Gets the {@link CacheManager} that owns and manages the {@link Cache}.
     *
     * @return the manager or <code>null</code> if the {@link Cache} is not
     *         managed
     */
    CacheManager getCacheManager();

    /**
     * Closing a {@link Cache} signals to the {@link CacheManager} that produced or
     * owns the {@link Cache} that it should no longer be managed. At this
     * point in time the {@link CacheManager}:
     * <ul>
     * <li>must close and release all resources being coordinated on behalf of the
     * Cache by the {@link CacheManager}. This includes calling the <code>close
     * </code> method on configured {@link CacheLoader},
     * {@link CacheWriter}, registered {@link CacheEntryListener}s and
     * {@link ExpiryPolicy} instances that implement the java.io.Closeable
     * interface.
     * <li>prevent events being delivered to configured {@link CacheEntryListener}s
     * registered on the {@link Cache}
     * </li>
     * <li>not return the name of the Cache when the CacheManager getCacheNames()
     * method is called</li>
     * </ul>
     * Once closed any attempt to use an operational method on a Cache will throw an
     * {@link IllegalStateException}.
     * <p>
     * Closing a Cache does not necessarily destroy the contents of a Cache.
     * It simply signals to the owning CacheManager that the Cache is no longer
     * required by the application and that future uses of a specific Cache instance
     * should not be permitted.
     * <p>
     * Depending on the implementation and Cache topology,
     * (e.g. a storage-backed or distributed cache), the contents of a closed Cache
     * may still be available and accessible by other applications, or, in fact, via
     * the Cache Manager that previously owned the Cache, if an application calls
     * getCache at some point in the future.
     *
     * @throws SecurityException when the operation could not be performed
     *                           due to the current security settings
     */
    void close();

    /**
     * Determines whether this Cache instance has been closed. A Cache is
     * considered closed if;
     * <ol>
     * <li>the {@link #close()} method has been called</li>
     * <li>the associated {@link #getCacheManager()} has been closed, or</li>
     * <li>the Cache has been removed from the associated
     * {@link #getCacheManager()}</li>
     * </ol>
     * <p>
     * This method generally cannot be called to determine whether a Cache instance
     * is valid or invalid. A typical client can determine that a Cache is invalid
     * by catching any exceptions that might be thrown when an operation is
     * attempted.
     *
     * @return true if this Cache instance is closed; false if it is still open
     */
    boolean isClosed();

    /**
     * Provides a standard way to access the underlying concrete caching
     * implementation to provide access to further, proprietary features.
     * <p>
     * If the provider's implementation does not support the specified class,
     * the {@link IllegalArgumentException} is thrown.
     *
     * @param <T> the type of the underlying {@link Cache} implementation
     * @param clazz the proprietary class or interface of the underlying concrete
     *              cache. It is this type that is returned.
     * @return an instance of the underlying concrete cache
     * @throws IllegalArgumentException if the caching provider doesn't support
     *                                  the specified class.
     * @throws SecurityException        when the operation could not be performed
     *                                  due to the current security settings
     */
    <T> T unwrap(java.lang.Class<T> clazz);

    /**
     * Registers a {@link CacheEntryListener}. The supplied
     * {@link CacheEntryListenerConfiguration} is used to instantiate a listener
     * and apply it to those events specified in the configuration.
     *
     * @param cacheEntryListenerConfiguration
     *         a factory and related configuration
     *         for creating the listener
     * @throws IllegalArgumentException is the same CacheEntryListenerConfiguration
     *                                  is used more than once
     * @throws IllegalStateException    if the cache is {@link #isClosed()}
     * @see CacheEntryListener
     */
    void registerCacheEntryListener(
            CacheEntryListenerConfiguration<K, V> cacheEntryListenerConfiguration);

    /**
     * Deregisters a listener, using the
     * {@link CacheEntryListenerConfiguration} that was used to register it.
     * <p>
     * Both listeners registered at configuration time,
     * and those created at runtime with {@link #registerCacheEntryListener} can
     * be deregistered.
     *
     * @param cacheEntryListenerConfiguration
     *         the factory and related configuration
     *         that was used to create the
     *         listener
     * @throws IllegalStateException if the cache is {@link #isClosed()}
     */
    void deregisterCacheEntryListener(CacheEntryListenerConfiguration<K, V>
                                              cacheEntryListenerConfiguration);

    /**
     * {@inheritDoc}
     * <p>
     * The ordering of iteration over entries is undefined.
     * <p>
     * During iteration, any entries that are removed will have their appropriate
     * CacheEntryRemovedListeners notified.
     * <p>
     * When iterating over a cache it must be assumed that the underlying
     * cache may be changing, with entries being added, removed, evicted
     * and expiring. {@link java.util.Iterator#next()} may therefore return
     * null.
     *
     * @throws IllegalStateException if the cache is {@link #isClosed()}
     */
    Iterator<Cache.Entry<K, V>> iterator();

    /**
     * A cache entry (key-value pair).
     */
    interface Entry<K, V> {

        /**
         * Returns the key corresponding to this entry.
         *
         * @return the key corresponding to this entry
         */
        K getKey();

        /**
         * Returns the value stored in the cache when this entry was created.
         *
         * @return the value corresponding to this entry
         */
        V getValue();

        /**
         * Provides a standard way to access the underlying concrete cache entry
         * implementation in order to provide access to further, proprietary features.
         * <p>
         * If the provider's implementation does not support the specified class,
         * the {@link IllegalArgumentException} is thrown.
         *
         * @param <T> the type of the underlying {@link Entry} implementation
         * @param clazz the proprietary class or interface of the underlying
         *              concrete cache. It is this type that is returned.
         * @return an instance of the underlying concrete cache
         * @throws IllegalArgumentException if the caching provider doesn't support
         *                                  the specified class.
         */
        <T> T unwrap(Class<T> clazz);
    }
}
```

### 缓存类型安全

Java Caching API 大量使用了 JSR-14 中定义的泛型，以便在采用缓存时能够开发编译时类型安全的应用程序。

编译时的类型安全性不能保证运行时类型正确性。 对于某些缓存实现，特别是那些跨Java进程存储或访问条目的缓存实现，Java运行时类型信息擦除以及无法获取和传输泛型信息可能意味着应用程序类型无法确保此类中缓存操作的类型安全性。 始终应注意确保使用适当的键和值类型配置缓存，以便实现可以根据需要或要求执行类型检查。

### 编译时类型安全

编译时类型安全由泛型来保证。

#### 例1

下面的这个例子中，Key 类型是 `String`，Value 类型是 `Integer`。当与 `Cache` 交互时使用了不兼容的类型时会报编译时错误。

```java
Configuration config = new MutableConfiguration();

//create the cache
cacheManager.createCache(cacheName, config);

//... then later to get the cache
Cache<String, Integer> cache = cacheManager.getCache(cacheName);

//use the cache
String key = "key";
Integer value1 = 1;
cache.put("key", value1);
Integer value2 = cache.get(key);


//the following will not compile - incorrect types specified
//cache.put(2, "some value");
```

尽管可以通过使用原始类型（不指定泛型类型参数）声明一个Cache来规避编译时类型安全检查，但不建议这样做，因为它允许发生简单的编程错误。

#### 例2

下面这个例子中，`Cache` 被声明为一个原始类型，这里面不会做编译时类型检查（尽管会生成类型警告）

```java
Configuration config = new MutableConfiguration();
cacheManager.createCache(cacheName, config);

//... then later to get the cache without type information
Cache cache = cacheManager.getCache(cacheName);
String key = "key";
Integer value1 = 1;
cache.put("key", value1);

cache.put(value1, "key1");  //not intended but will still compile and execute!
Integer value2 = (Integer) cache.get(key);
assertEquals(value1, value2);
```

### 运行时类型安全

除了编译时类型安全，开发者可以通过配置 `Cache` 的 key 和 Value 的类型来保证运行时类型安全。例如，`MutableConfiguration` 类提供了下面的方法来定义需要的key 和 Value 类型。

```java
/**
 * Sets the expected type of keys and values for a {@link Cache}
 * configured with this {@link Configuration}. Setting both to
 * <code>Object.class</code> means type-safety checks are not required.
 * <p/>
 * This is used by {@link CacheManager} to ensure that the key and value
 * types are the same as those configured for the {@link Cache} prior to
 * returning a requested cache from this method.
 * <p/>
 * Implementations may further perform type checking on mutative cache operations
 * and throw a {@link ClassCastException} if these checks fail.
 *
 * @param keyType   the expected key type
 * @param valueType the expected value type
 * @return the {@link MutableConfiguration} to permit fluent-style method calls
 * @throws NullPointerException should the key or value type be null
 * @see CacheManager#getCache(String, Class, Class)
 */
public MutableConfiguration<K, V> setTypes(Class<K> keyType, Class<V> valueType)
```

当缓存配置定义了 key 和 Value 的类型，由 `CacheManager.getCache` 返回的 `Cache` 必须强制入参的的键和值类型与配置的键和值类型相同。此时必须使用下面的方法来获取缓存

```java
<K, V> Cache<K, V> getCache(String cacheName, Class<K> keyType, Class<V> valueType);
```

当使用上面的方法时，缓存实现必须确保返回的缓存显式配置了键值类型。这给开发者提供了相比仅使用泛型更高级别的安全性。

实现可以在可变缓存操作时做运行时类键值检查。

当配置未定义所需的键和值类型，或者它们都定义为 `Object.class` 时，在请求缓存时，不需要实现来执行运行时类型检查。 要在不检查使用的情况下请求缓存使用：

```java
 <K, V> Cache<K, V> Cache getCache(String cacheName);
```

在没有配置键值类型的情况下，尝试使用具有特定类型参数的 `getCache` 会引发 `IllegalArgumentException`。 对任何具有特定键和值类型配置的键或没有定义键或值类型或两者均为 `Object.class` 的任何 `Cache` 使用不带特定类型参数的 `getCache` 时，将返回不进行任何类型检查的 `Cache`。

#### 例子

在此示例中，缓存配置为具有字符串键类型和整数值类型。 然后，实现将确保声明的类型与配置的缓存匹配，否则将抛出`IllegalArgumentException`。

```java
CachingProvider cachingProvider = Caching.getCachingProvider();
CacheManager cacheManager = cachingProvider.getCacheManager();

MutableConfiguration<String, Integer> config = new
    MutableConfiguration<String, Integer>();
config.setTypes(String.class, Integer.class);
cacheManager.createCache("simpleCache", config);

//... then later to get the cache without type information
Cache<String, Integer> simpleCache = cacheManager.getCache("simpleCache",
    String.class, Integer.class);

simpleCache.put("key1", 3);
Integer value2 = simpleCache.get("key1");
```

尽管 Java Caching API 提供了用于编译和运行时类型安全的机制，但是类型检查仅适用于键和值的可验证类型，包括所有通用集合类型。
例如，类型 `List<MyClass>` 在运行时不可修改，因此只能与类型 `List.class` 进行比较。

## 过期策略

如果条目已过期，它就不能从缓存中被获取到。如果 `Cache` 没有配置过期策略，默认用不过期

虽然“用不过期”策略不自动过期条目，但是缓存实现可以支持手动驱逐。

过期策略在配置时指定，过期策略需要实现 `ExpiryPolicy` 接口，接口定义如下：

```java
package javax.cache.expiry;

/**
 * Defines functions to determine when cache entries will expire based on
 * creation, access and modification operations.
 * <p>
 * Each of the functions return a new {@link Duration} that specifies the
 * amount of time that must pass before a cache entry is considered expired.
 * {@link Duration} has constants defined for useful durations.
 *
 * @author Brian Oliver
 * @author Greg Luck
 * @since 1.0
 * @see Duration
 */
public interface ExpiryPolicy {

  /**
   * Gets the {@link Duration} before a newly created Cache.Entry is considered
   * expired.
   * <p>
   * This method is called by a caching implementation after a Cache.Entry is
   * created, but before a Cache.Entry is added to a cache, to determine the
   * {@link Duration} before an entry expires.  If a {@link Duration#ZERO}
   * is returned the new Cache.Entry is considered to be already expired and
   * will not be added to the Cache.
   * <p>
   * Should an exception occur while determining the Duration, an implementation
   * specific default {@link Duration} will be used.
   *
   * @return the new {@link Duration} before a created entry expires
   */
  Duration getExpiryForCreation();

  /**
   * Gets the {@link Duration} before an accessed Cache.Entry is
   * considered expired.
   * <p>
   * This method is called by a caching implementation after a Cache.Entry is
   * accessed to determine the {@link Duration} before an entry expires.  If a
   * {@link Duration#ZERO} is returned a Cache.Entry will be
   * considered immediately expired.  Returning <code>null</code> will result
   * in no change to the previously understood expiry {@link Duration}.
   * <p>
   * Should an exception occur while determining the Duration, an implementation
   * specific default Duration will be used.
   *
   * @return the new {@link Duration} before an accessed entry expires
   */
  Duration  getExpiryForAccess();

  /**
   * Gets the {@link Duration} before an updated Cache.Entry is considered
   * expired.
   * <p>
   * This method is called by the caching implementation after a Cache.Entry is
   * updated to determine the {@link Duration} before the updated entry expires.
   * If a {@link Duration#ZERO} is returned a Cache.Entry is considered
   * immediately expired.  Returning <code>null</code> will result in no change
   * to the previously understood expiry {@link Duration}.
   * <p>
   * Should an exception occur while determining the Duration, an implementation
   * specific default Duration will be used.
   *
   * @return the new {@link Duration} before an updated entry expires
   */
  Duration getExpiryForUpdate();
}
```

缓存条目在执行完指定操作一段时间后过期，这个时间间隔由 `javax.cache.expiry.Duration` 来定义。 `Duration` 由 `java.util.concurrent.TimeUnit` 和 `long durationAmount` 两部分组成，最小的时间单位是 `TimeUnit.MILLISECONDS`;

过期时间由配置的过期策略和执行的缓存操作有关。下面是 `ExpiryPolicy` 接口中对于指定操作获取对应的时间间隔的方法

- `getExpiryForCreation()` 条目创建时的有效时长
- `getExpiryForAccess()` 条目被访问时新的有效时长
- `getExpiryForUpdate()` 条目更新时新的有效时长

当一个缓存实现调用了上面的三个方法,会返回下面几种结果其中之一：

- 一个新的有效时长
- `Duration.ZERO`，代表条目立即过期
- `null`，`getExpiryForUpdate()` 和 `getExpiryForAccess()` 可能返回，代表不修改条目当前的有效时长。

除了 `Duration#ZERO`，还定义了如下常量

```java

  /**
   * ETERNAL (forever).
   */
  public static final Duration ETERNAL = new Duration();

  /**
   * One day.
   */
  public static final Duration ONE_DAY = new Duration(DAYS, 1);

  /**
   * One hour.
   */
  public static final Duration ONE_HOUR = new Duration(HOURS, 1);

  /**
   * Thirty minutes.
   */
  public static final Duration THIRTY_MINUTES = new Duration(MINUTES, 30);

  /**
   * Twenty minutes.
   */
  public static final Duration TWENTY_MINUTES = new Duration(MINUTES, 20);

  /**
   * Ten minutes.
   */
  public static final Duration TEN_MINUTES = new Duration(MINUTES, 10);

  /**
   * Five minutes.
   */
  public static final Duration FIVE_MINUTES = new Duration(MINUTES, 5);

  /**
   * One minute.
   */
  public static final Duration ONE_MINUTE = new Duration(MINUTES, 1);

  /**
   * Zero (no time).
   */
  public static final Duration ZERO = new Duration(SECONDS, 0);
```

下面的表格中描述了缓存方法如何与过期策略进行交互

|缓存方法|`ExpiryPolicy.getExpiryForCreation`<br> 是否调用|`ExpiryPolicy.getExpiryForAccess`<br> 是否调用|`ExpiryPolicy.getExpiryForUpdate`<br> 是否调用|
|---|---|---|---|
|`boolean containsKey(K key)`|NO|NO|NO|
|`V get(K key)`|NO (unless read-though caused a load)|YES|NO|
|`Map<K,V> getAll(Collection<? extends K> keys)`|No (unless read-though caused a load)|YES|NO|
|`V getAndPut(K key, V value)`|YES (when the key is not associated with an existing value)|NO|YES (when the key is associated with an existing value)|
|`V getAndRemove(K key)`|NO|NO|NO|
|`V getAndReplace(K key, V value)`|NO|NO|Yes (when the key is associated with an existing value)|
|`CacheManager getCacheManager()`|NO|NO|NO|
|`CacheConfiguration getConfiguration()`|NO|NO|NO|
|`String getName()`|NO|NO|NO|
|`Iterator<Cache.Entry<K, V>> iterator()`|NO|YES (when an entry is visited by an iterator)|NO|
|`void loadAll(Set<? extends K> keys, boolean replaceExistingValues, CompletionListener listener)`|YES (when a key is not associated with a loaded value)|NO|YES (when a key is associated with a loaded value and the value should be replaced)|
|`void put(K key, V value)`|YES (when the key is not associated with an existing value)|NO|YES (when the key is associated with an existing value)|
|`void putAll(Map<? extends K,? extends V> map)`|YES (when the key is not associated with an existing value)|NO|YES(when the key is associated with an existing value)|
|`boolean putIfAbsent(K key, V value)`|YES (when the key is not associated with an existing value)|NO|NO|
|`boolean remove(K key)`|NO|NO|NO|
|`boolean remove(K key, V oldValue)`|NO|YES (when the old value does not match the existing value)|NO|
|`void removeAll()`|NO|NO|NO|
|`void removeAll(Set<? extends K> keys)`|NO|NO|NO|
|`<T> T invoke(K key, EntryProcessor<K, V, T> entryProcessor, Object... arguments)entryProcessor);`|Yes (for the following cases:<br>(1) setValue called and entry did not exist for key before invoke was called.<br>(2) if read-through enabled and getValue() is called and causes a new entry to be loaded for key)|Yes (when getValue was called and no other mutations occurred during entry processor execution. note: Create, modify or remove take precedence over Access)|Yes (when setValue was called and the entry already existed before entry processor was called)|
|`<T> Map<K, EntryProcessorResult<T>> invokeAll(Set<? extends K> keys, EntryProcessor<K, V, T> entryProcessor, Object... arguments);`|同 invoke|同 invoke|同 invoke|
|`boolean replace(K key, V value)`|NO|NO|YES (when the key is associated with an existing value)|
|`boolean replace(K key, V oldValue, V newValue)`|NO|YES (when value is not replaced)|YES (when value is replaced)|
|`<T> T unwrap(Class<T> cls)`|NO|NO|NO|

本规范预定义了五种过期策略，在 `javax.cache.expiry` 包下可以找到对应实现:

- `CreatedExpiryPolicy` 创建后一段时间过期。
- `ModifiedExpiryPolicy` 创建后一段时间过期，更新时刷新过期时间。
- `AccessedExpiryPolicy` 创建后一段时间过期，访问时刷新过期时间。
- `TouchedExpiryPolicy` 创建后一段时间过期，访问或更新时刷新过期时间。
- `EternalExpiryPolicy` 用不过期，这是默认的过期策略。

## 集成

`javax.cache.integration` 包里提供了一些便于与外部资源整合的工具。

下面定义了 `CacheLoader` 和 `CacheWriter` 类：

```java
package javax.cache.integration;

import javax.cache.configuration.CompleteConfiguration;
import java.util.Map;

/**
 * Used when a cache is read-through or when loading data into a cache via the
 * {@link javax.cache.Cache#loadAll(java.util.Set, boolean,
 * CompletionListener)} method.
 *
 * @param <K> the type of keys handled by this loader
 * @param <V> the type of values generated by this loader
 * @author Greg Luck
 * @author Yannis Cosmadopoulos
 * @see CompleteConfiguration#isReadThrough()
 * @see CacheWriter
 * @since 1.0
 */
public interface CacheLoader<K, V> {

  /**
   * Loads an object. Application developers should implement this
   * method to customize the loading of a value for a cache entry. This method
   * is called by a cache when a requested entry is not in the cache. If
   * the object can't be loaded <code>null</code> should be returned.
   *
   * @param key the key identifying the object being loaded
   * @return The value for the entry that is to be stored in the cache or
   *         <code>null</code> if the object can't be loaded
   * @throws CacheLoaderException if there is problem executing the loader.
   */
  V load(K key) throws CacheLoaderException;



  /**
   * Loads multiple objects. Application developers should implement this
   * method to customize the loading of cache entries. This method is called
   * when the requested object is not in the cache. If an object can't be loaded,
   * it is not returned in the resulting map.
   *
   * @param keys keys identifying the values to be loaded
   * @return A map of key, values to be stored in the cache.
   * @throws CacheLoaderException if there is problem executing the loader.
   */
  Map<K, V> loadAll(Iterable<? extends K> keys) throws CacheLoaderException;
}

```

```java
package javax.cache.integration;


import javax.cache.Cache;
import java.util.Collection;

/**
 * A CacheWriter is used for write-through to an external resource.
 * <p>
 * Under Default Consistency, the non-batch writer methods are atomic with respect
 * to the corresponding cache operation.
 * <p>
 * For batch methods under Default Consistency, the entire cache operation
 * is not required to be atomic in {@link Cache} and is therefore not required to
 * be atomic in the writer. As individual writer operations can fail, cache
 * operations are not required to occur until after the writer batch method has
 * returned or, in the case of partial success, thrown an exception. In the case
 * of partial success, the collection of entries return must only contain
 * those entries that failed.
 * <p>
 * The entry passed into {@link #write(Cache.Entry)} is independent
 * of the cache mapping for that key, meaning that if the value changes in the
 * cache or is removed it does not change the entry.
 *
 * @param <K> the type of keys maintained by this map
 * @param <V> the type of mapped values
 * @author Greg Luck
 * @author Brian Oliver
 * @see CacheLoader
 * @since 1.0
 */
public interface CacheWriter<K, V> {


  /**
   * Write the specified value under the specified key to the external resource.
   * <p>
   * This method is intended to support both key/value creation and value update
   * for a specific key.
   *
   * @param entry the entry to be written
   * @throws CacheWriterException if the write fails. If thrown the
   *                              cache mutation will not occur.
   */
  void write(Cache.Entry<? extends K, ? extends V> entry) throws CacheWriterException;

  /**
   * Write the specified entries to the external resource. This method is intended
   * to support both insert and update.
   * <p>
   * The order that individual writes occur is undefined, as
   * {@link Cache#putAll(java.util.Map)} also has undefined ordering.
   * <p>
   * If this operation fails (by throwing an exception) after a partial success,
   * the writer must remove any successfully written entries from the entries
   * collection so that the caching implementation knows what succeeded and can
   * mutate the cache.
   *
   * @param entries a mutable collection to write. Upon invocation, it contains
   *                the entries to write for write-through. Upon return the
   *                collection must only contain entries that were not
   *                successfully written. (see partial success above)
   * @throws CacheWriterException if one or more of the writes fail. If
   *                              thrown cache mutations will occur for
   *                              entries that succeeded.
   */
  void writeAll(Collection<Cache.Entry<? extends K, ? extends V>> entries) throws
      CacheWriterException;


  /**
   * Delete the cache entry from the external resource.
   * <p>
   * Expiry of a cache entry is not a delete hence will not cause this method to
   * be invoked.
   * <p>
   * This method is invoked even if no mapping for the key exists.
   *
   * @param key the key that is used for the delete operation
   * @throws CacheWriterException if delete fails. If thrown the cache delete will
   *                              not occur.
   */
  void delete(Object key) throws CacheWriterException;


  /**
   * Remove data and keys from the external resource for the given collection of
   * keys, if present.
   * <p>
   * The order that individual deletes occur is undefined, as
   * {@link Cache#removeAll(java.util.Set)} also has undefined ordering.
   * <p>
   * If this operation fails (by throwing an exception) after a partial success,
   * the writer must remove any successfully written entries from the entries
   * collection so that the caching implementation knows what succeeded and can
   * mutate the cache.
   * <p>
   * Expiry of a cache entry is not a delete hence will not cause this method to
   * be invoked.
   * <p>
   * This method may include keys even if there is no mapping for that key,
   * in which case the data represented by that key should be removed from the
   * underlying resource.
   *
   * @param keys a mutable collection of keys for entries to delete. Upon
   *             invocation, it contains the keys to delete for write-through.
   *             Upon return the collection must only contain the keys that were
   *             not successfully deleted. (see partial success above)
   * @throws CacheWriterException if one or more deletes fail. If thrown
   *                              cache deletes will occur for entries that
   *                              succeeded.
   */
  void deleteAll(Collection<?> keys) throws CacheWriterException;
}
```

### 缓存加载

`loadAll` 方法用来将外部资源加载到缓存中，定义如下：

```java
/**
* Asynchronously loads the specified entries into the cache using the
* configured {@link CacheLoader} for the given keys.
* <p>
* If an entry for a key already exists in the Cache, a value will be loaded
* if and only if <code>replaceExistingValues</code> is true.   If no loader
* is configured for the cache, no objects will be loaded.  If a problem is
* encountered during the retrieving or loading of the objects,
* an exception is provided to the {@link CompletionListener}.  Once the
* operation has completed, the specified CompletionListener is notified.
* <p>
* Implementations may choose to load multiple keys from the provided
* {@link Set} in parallel.  Iteration however must not occur in parallel,
* thus allow for non-thread-safe {@link Set}s to be used.
* <p>
* The thread on which the completion listener is called is implementation
* dependent. An implementation may also choose to serialize calls to
* different CompletionListeners rather than use a thread per
* CompletionListener.
*
* @param keys                  the keys to load
* @param replaceExistingValues when true existing values in the Cache will
*                              be replaced by those loaded from a CacheLoader
* @param completionListener    the CompletionListener (may be null)
* @throws NullPointerException  if keys is null or if keys contains a null.
* @throws IllegalStateException if the cache is {@link #isClosed()}
* @throws CacheException        thrown if there is a problem performing the
*                               load. This may also be thrown on calling if
*                               there are insufficient threads available to
*                               perform the load.
* @throws ClassCastException    if the implementation is configured to perform
*                               runtime-type-checking, and the key or value
*                               types are incompatible with those that have been
*                               configured for the {@link Cache}
*/
void loadAll(Set<? extends K> keys, boolean replaceExistingValues,
CompletionListener completionListener);
```

为了使用这个方法，在创建缓存时必须配置 `CacheLoader`。不需要将缓存配置为 `read-through` 模式。

加载可能耗时较长，因为这个原因，可以给该方法传递一个 `CompletionListener`，来接收加载完成或加载异常的通知。该接口的定义如下：

```java
package javax.cache.integration;

/**
 * A CompletionListener is implemented by an application when it needs to be
 * notified of the completion of some Cache operation.
 * <p>
 * When the operation is complete, the Cache provider notifies the application
 * by calling the {@link #onCompletion()} method of the {@link
 * CompletionListener}.
 * <p>
 * If the operation fails for any reason, the Cache provider calls the
 * {@link #onException(Exception)} method of the {@link CompletionListener}.
 * <p>
 * To support a Java Future-based approach to synchronously wait for a Cache
 * operation to complete, use a {@link CompletionListenerFuture}.
 * <p>
 * A Cache provider will use an implementation specific thread to call methods
 * on this interface.
 *
 * @author Brian Oliver
 * @since 1.0
 * @see CompletionListenerFuture
 */
public interface CompletionListener {

  /**
   * Notifies the application that the operation completed successfully.
   */
  void onCompletion();

  /**
   * Notifies the application that the operation failed.
   *
   * @param e the Exception that occurred
   */
  void onException(Exception e);
}
```

本规范也提供了一个阻塞版本的 `CompletionListener` 实现，`CompletionListenerFuture`。它实现了 `CompletionListener` 和 `Future` 两个接口。如果 `onException(Exception e)` 方法被调用，异常会被重新封装成 `ExecutionException` 由 `Future get()/get(long timeout, TimeUnit unit)` 重抛。

#### 例子

```java
HashSet<String> keys = new HashSet<>();
keys.add("23432lkj");
keys.add("4fsdldkj");


//create a completion future to use to wait for loadAll
CompletionListenerFuture future = new CompletionListenerFuture();

//load the values for the set of keys, replacing those that may already
//exist in the cache
cache.loadAll(keys, true, future);

//wait for the cache to load the keys
try {
  future.get();
} catch (InterruptedException e) {
  //future interrupted
  e.printStackTrace();
} catch (ExecutionException e) {
  //throwable was what was sent to onException(Exception e)
  Throwable throwable = e.getCause();
}

```

`loadAll` 方法用来从外部资源预加载数据非常有用。一种用法是应用程序假定缓存一定存在，不然会有异常；另一种是用来做缓存预热，如果缓存中没有数据，不会导致错误，但是会对性能有影响。

### `Read-Through` 模式

`Read-Through` 模式和非`Read-Through` 模式几乎完全相同，不同之处就在于当缓存中没有数据时，会调用 `CacheLoader` 去加载。

通过 `MutableConfiguration`  上调用 `setReadThrough(boolean isReadThrough)` 来配置该模式，与该模式配套的 `CacheLoader Factory` 也必须配置。

下表用于描述 `Cache` 的那些方法会使用该模式加载数据：

|方法|启用 Read-Through|
|---|---|
|`boolean containsKey(K key)`| NO|
|`V get(K key)`| YES |
|`Map<K,V> getAll(Collection<? extends K> keys)`|YES, 调用 `loadAll()`|
|`V getAndPut(K key, V value)`|NO|
|`V getAndRemove(K key)`|NO|
|`V getAndReplace(K key, V value)`|NO|
|`<T> T invoke(K key, EntryProcessor<K, V, T> entryProcessor, Object... arguments)entryProcessor);`|当 `getValue()` 被调用时|
|`<T> Map<K, EntryProcessorResult<T>> invokeAll(Set<? extends K> keys,EntryProcessor<K, V, T> entryProcessor, Object... arguments);`|当 `getValue()` 被调用时|
|`Iterator<Cache.Entry<K, V>> iterator()`|NO|
|`void loadAll(Set<? extends K> keys, boolean replaceExistingValues, CompletionListener listener)`|YES,使用 `CacheLoader.loadAll()`，不管当前缓存是否是 Read-Through 模式|
|`void put(K key, V value)`|NO|
|`void putAll(Map<? extends K,? extends V> map)`|NO|
|`boolean putIfAbsent(K key, V value)`|NO|
|`boolean remove(K key)`|NO|
|`boolean remove(K key, V oldValue)`|NO|
|`void removeAll()`|NO|
|`void removeAll(Set<? extends K> keys)`|NO|
|`boolean replace(K key, V value)`|NO|
|`boolean replace(K key, V oldValue, V newValue)`|NO|

Read-Through 模式的使用惯例是懒加载。在屏蔽缓存加载的细节上，这种模式也很有用。

当 一些或全部数据需要被预先加载时，使用 `loadAll` 方法。

### `Write-Through` 模式

`Write-Through` 模式和非`Write-Through` 模式几乎完全相同，不同之处就在于当缓存数据变更时，会调用 `CacheWriter`。

通过 `MutableConfiguration`  上调用 `setWriteThrough(boolean isWriteThrough)` 来配置该模式，与该模式配套的 `CacheWriter Factory` 也必须配置。`CacheWriter` 用来更新/删除外部资源。

下表用于描述 `Cache` 的那些方法会使用该模式将变更写到外部资源：

|方法|启用 Write-Through|
|---|---|
|`boolean containsKey(K key)`| NO|
|`V get(K key)`| NO |
|`Map<K,V> getAll(Collection<? extends K> keys)`|NO|
|`V getAndPut(K key, V value)`|YES|
|`V getAndRemove(K key)`|YES|
|`V getAndReplace(K key, V value)`|当Key能查到对应Value时|
|`<T> T invoke(K key, EntryProcessor<K, V, T> entryProcessor, Object... arguments)entryProcessor);`|当 `setValue()` 被调用时|
|`<T> Map<K, EntryProcessorResult<T>> invokeAll(Set<? extends K> keys,EntryProcessor<K, V, T> entryProcessor, Object... arguments);`|当 `setValue()` 被调用时|
|`Iterator<Cache.Entry<K, V>> iterator()`|NO|
|`void loadAll(Set<? extends K> keys, boolean replaceExistingValues, CompletionListener listener)`|NO|
|`void put(K key, V value)`|YES|
|`void putAll(Map<? extends K,? extends V> map)`|YES，将会调用 `writeAll`|
|`boolean putIfAbsent(K key, V value)`|返回true时|
|`boolean remove(K key)`|YES，不管key是否存在|
|`boolean remove(K key, V oldValue)`|返回true时|
|`void removeAll()`|YES，将会调用 `deleteAll`|
|`void removeAll(Set<? extends K> keys)`|YES, 不管key是否存在|
|`void clear()`|NO|
|`boolean replace(K key, V value)`|返回true时|
|`boolean replace(K key, V oldValue, V newValue)`|返回true时|

`Write-Through` 主要用于在缓存更新时对外部资源进行更新。该模式对用户屏蔽了写入外部资源的细节。

## 参考

1. [JSR107 Specification 1.1.1 Maintenance Release - Google Doc](https://docs.google.com/document/d/1ijduF_tmHvBaUS7VBBU2ZN8_eEBiFaXXg9OI0_ZxCrA/edit?usp=sharing)
1. [jsr107/jsr107spec - GitHub](https://github.com/jsr107/jsr107spec)
1. [jsr107 - jcp.org](https://jcp.org/aboutJava/communityprocess/final/jsr107/index.html)
